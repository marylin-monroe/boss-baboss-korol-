//@version=5
strategy("boss/baboss [korol]", 
         shorttitle="BABOSS", 
         overlay=true, 
         pyramiding=20, 
         default_qty_type=strategy.percent_of_equity, 
         default_qty_value=5, 
         initial_capital=10000, 
         commission_type=strategy.commission.percent, 
         commission_value=0.1,
         calc_on_order_fills=true,
         calc_on_every_tick=false,
         max_labels_count=500,
         max_lines_count=500,
         max_bars_back=5000,
         process_orders_on_close=true,
         use_bar_magnifier=false)

// ===============================
// CSV IMPORT/EXPORT FUNCTIONALITY
// ===============================
csv_group = "═══════════ CSV Import/Export ═══════════"
csv_string = input.text_area("", "Paste CSV String Here (for import)", group=csv_group)
show_export = input.bool(false, "Show Export String", group=csv_group)
export_button = input.bool(false, "Generate Export String", group=csv_group)

// ===============================
// HELPER FUNCTIONS
// ===============================
// Enhanced Moving Average Function
ma_function(src, length, ma_type) =>
    result = 0.0
    if ma_type == "SMA"
        result := ta.sma(src, length)
    else if ma_type == "EMA"
        result := ta.ema(src, length)
    else if ma_type == "RMA"
        result := ta.rma(src, length)
    else if ma_type == "WMA"
        result := ta.wma(src, length)
    else if ma_type == "HMA"
        result := ta.hma(src, length)
    else if ma_type == "VWMA"
        result := ta.vwma(src, length)
    else if ma_type == "TEMA"
        ema1 = ta.ema(src, length)
        ema2 = ta.ema(ema1, length)
        ema3 = ta.ema(ema2, length)
        result := 3 * (ema1 - ema2) + ema3
    else if ma_type == "DEMA"
        ema1 = ta.ema(src, length)
        ema2 = ta.ema(ema1, length)
        result := 2 * ema1 - ema2
    else
        result := ta.ema(src, length)
    result

// ===============================
// VISUALIZATION SETTINGS
// ===============================
viz_group = "═══════════ Visualization ═══════════"
showTPSL = input.bool(true, "Display Visualisation for TP/SL ?", group=viz_group)
showSignals = input.bool(true, "Show Signals ?", group=viz_group)
showLastSignalLines = input.bool(false, "Show Last Signal Lines ?", group=viz_group)
visualizeTrailingActivation = input.bool(false, "Visualise Trailing Activation Price ?", group=viz_group)

// ===============================
// PERIOD AND DAYS SETTINGS
// ===============================
period_group = "═══════════ Period Settings ═══════════"
startYear = input.int(2022, "Start Year", minval=2000, maxval=2100, group=period_group)
stopYear = input.int(2025, "Stop Year", minval=2000, maxval=2100, group=period_group)

days_group = "═══════════ Days To Block ═══════════"
blockSu = input.bool(false, "Su", group=days_group, inline="days1")
blockMo = input.bool(false, "Mo", group=days_group, inline="days1") 
blockTu = input.bool(false, "Tu", group=days_group, inline="days1")
blockWe = input.bool(false, "We", group=days_group, inline="days1")
blockTh = input.bool(false, "Th", group=days_group, inline="days2")
blockFr = input.bool(false, "Fr", group=days_group, inline="days2")
blockSa = input.bool(false, "Sa", group=days_group, inline="days2")

// ===============================
// DCA GRID SETTINGS
// ===============================
dca_group = "═══════════ DCA Grid Settings ═══════════"
enableDCA = input.bool(true, "Activate DCA Grid ?", group=dca_group)
gridDirection = input.string("Long", "Long or Short Grid ?", options=["Long", "Short"], group=dca_group)
depositForBot = input.float(50, "Deposit for Bot (for the entire grid) ($)", minval=1, group=dca_group)
leverage = input.int(20, "Leverage (1x-20x)", minval=1, maxval=20, group=dca_group)
gridSizePercent = input.float(2.9, "Grid Size (%)", minval=0.1, maxval=50.0, step=0.1, group=dca_group)
numberOfOrders = input.int(4, "Number of orders in the grid (3-15)", minval=3, maxval=15, group=dca_group)
martingaleMultiplier = input.float(1.05, "Orders Value Martingale (1.0-1.8)", minval=1.0, maxval=1.8, step=0.01, group=dca_group)
logarithmicSteps = input.float(0.9, "Logarithmic Orders Steps (0.8-1.4)", minval=0.8, maxval=1.4, step=0.1, group=dca_group)
closeOnBigDrawdown = input.bool(false, "Close All Orders on Big Drawdown ?", group=dca_group)
drawdownToClose = input.float(-95, "Drawdown to close (-$)", group=dca_group)
changeTakeProfit = input.bool(false, "Change Take Profit if Many Orders ?", group=dca_group)
newTakeProfitPercent = input.float(1.25, "Set Take Profit to X%", minval=0.1, maxval=5.0, step=0.01, group=dca_group)
ifOrdersMoreThan = input.int(3, "If Orders more than N", minval=2, maxval=15, group=dca_group)
sendAlertFirstOrder = input.bool(true, "Send Alert only for First Order", group=dca_group)

// ===============================
// DIRECTION AND TP/SL SETTINGS
// ===============================
dir_group = "═══════════ Direction ═══════════"
useLong = input.bool(true, "Use Long ?", group=dir_group)
useShort = input.bool(false, "Use Short ?", group=dir_group)

tpsl_group = "═══════════ TP/SL Settings ═══════════"
takeProfitPercent = input.float(2.1, "Take Profit (%)", minval=0.1, maxval=20.0, step=0.1, group=tpsl_group)
stopLossPercent = input.float(1.4, "Stop Loss (%)", minval=0.1, maxval=50.0, step=0.1, group=tpsl_group)
slEqualsTp = input.bool(false, "SL=TP ? (for optimization)", group=tpsl_group)
close_static_tp_sl = input.bool(true, "Close on Static TP/SL", group=tpsl_group)
closeOnlyInProfit = input.bool(false, "Close only in Profit. (Used only for \"Close Conditions\")", group=tpsl_group)

// Reverse Orders
useReverseOrderOnSL = input.bool(false, "Reverse order on SL", group=tpsl_group)
useReverseOrderOnBE = input.bool(false, "Reverse order on BE", group=tpsl_group)
reverse_qty_percent = input.int(100, "Reverse Order Size (%)", minval=10, maxval=200, group=tpsl_group)

// ===============================
// BREAKEVEN SETTINGS
// ===============================
be_group = "═══════════ Breakeven ═══════════"
useBreakeven = input.bool(false, "Activate Breakeven ?", group=be_group)
breakevenActivation = input.float(0.9, "(%) to Activate Breakeven", minval=0.1, maxval=10.0, step=0.01, group=be_group)
breakevenLevel = input.float(0.01, "New Breakeven SL (%)", minval=0.0, maxval=5.0, step=0.01, group=be_group)

// ===============================
// MULTI TAKE PROFITS
// ===============================
mtp_group = "═══════════ Multi Take Profits ═══════════"
useMultiTP = input.bool(false, "Use Multiple Take Profits ?", group=mtp_group)
tp1_percent = input.float(0.6, "Profit Percent for 1 TP (%)", minval=0.1, maxval=10.0, step=0.1, group=mtp_group)
tp1_qty = input.int(15, "Value of 1 TP (%)", minval=10, maxval=90, group=mtp_group)
tp2_percent = input.float(0.8, "Profit Percent for 2 TP (%)", minval=0.1, maxval=15.0, step=0.1, group=mtp_group)
tp2_qty = input.int(15, "Value of 2 TP (%)", minval=10, maxval=90, group=mtp_group)
tp3_percent = input.float(1.0, "Profit Percent for 3 TP (%)", minval=0.1, maxval=20.0, step=0.1, group=mtp_group)
tp3_qty = input.int(15, "Value of 3 TP (%)", minval=10, maxval=90, group=mtp_group)
tp4_percent = input.float(1.4, "Profit Percent for 4 TP (%)", minval=0.1, maxval=30.0, step=0.1, group=mtp_group)
tp4_qty = input.int(100, "Value of 4 TP (%) (Always All Remained)", minval=10, maxval=100, group=mtp_group)

// ===============================
// PYRAMIDING SETTINGS
// ===============================
pyr_group = "═══════════ Pyramiding ═══════════"
usePyramiding = input.bool(false, "Use Averaging ? (Pyramiding)", group=pyr_group)
pyramidMinMove = input.float(0.5, "Min price move for averaging (%)", minval=0.1, maxval=5.0, step=0.1, group=pyr_group)

// ===============================
// TRAILING STOP
// ===============================
trail_group = "═══════════ Trailing Stop ═══════════"
useTrailingStop = input.bool(false, "Use Trailing Stop ? Read Warning ->", group=trail_group)
trailingActivation = input.float(1.5, "Activate Trailing Stop at %", minval=0.1, maxval=10.0, step=0.1, group=trail_group)
trailingDistance = input.float(0.5, "Distance from price to Trailing Stop (%)", minval=0.1, maxval=5.0, step=0.1, group=trail_group)

// ===============================
// ORDER INDENT
// ===============================
indent_group = "═══════════ Order Indent ═══════════"
useOrderIndent = input.bool(false, "Use Indent Order ?", group=indent_group)
indentPercent = input.float(0.1, "Indent in % (0.1)", minval=-2.0, maxval=2.0, step=0.01, group=indent_group)
indentCancelBars = input.int(15, "Cancel Indent Order (if not executed) After X Bars", minval=1, maxval=50, group=indent_group)

// ===============================
// ATR STOP LOSS AND TAKE PROFIT
// ===============================
atr_group = "═══════════ ATR SL/TP ═══════════"
useATRStopLoss = input.bool(false, "Use ATR Stop Loss", group=atr_group)
atr_sl_length = input.int(14, "ATR SL Length", minval=1, maxval=50, group=atr_group)
atr_sl_multiplier = input.float(2.0, "ATR SL Multiplier", minval=0.5, maxval=10.0, step=0.1, group=atr_group)

useATRTakeProfit = input.bool(false, "Use ATR Take Profit", group=atr_group)
atr_tp_length = input.int(14, "ATR TP Length", minval=1, maxval=50, group=atr_group)
atr_tp_multiplier = input.float(2.0, "ATR TP Multiplier", minval=0.5, maxval=10.0, step=0.1, group=atr_group)

// ===============================
// VOLUME AND VOLATILITY FILTERS
// ===============================
vol_filter_group = "═══════════ Volume Filter ═══════════"
useVolumeFilter = input.bool(false, "Use Volume Filter", group=vol_filter_group)
volume_length = input.int(20, "Volume Length", minval=5, maxval=100, group=vol_filter_group)
volume_multiplier = input.float(1.5, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1, group=vol_filter_group)
volume_condition = input.string("Above Average", "Volume Condition", options=["Above Average", "Below Average", "Rising", "Falling"], group=vol_filter_group)

volat_filter_group = "═══════════ Volatility Filter ═══════════"
useVolatilityFilter = input.bool(false, "Use Volatility Filter", group=volat_filter_group)
vol_length = input.int(20, "Volatility Length", minval=5, maxval=100, group=volat_filter_group)
vol_threshold = input.float(1.0, "Volatility Threshold", minval=0.1, maxval=10.0, step=0.1, group=volat_filter_group)
vol_condition = input.string("Rising", "Volatility Condition", options=["Rising", "Falling", "Above Level", "Below Level"], group=volat_filter_group)

// ===============================
// HIGH/LOW PERIOD FILTER
// ===============================
hl_filter_group = "═══════════ High/Low Filter ═══════════"
useHighLowFilter = input.bool(false, "Use Highest/Lowest Filter", group=hl_filter_group)
highlow_period = input.int(20, "Period for High/Low", minval=5, maxval=200, group=hl_filter_group)
highlow_min_change = input.float(2.0, "Min Change % for Signal", minval=0.1, maxval=10.0, step=0.1, group=hl_filter_group)

// ===============================
// ATR CHANGE FILTER
// ===============================
atr_change_group = "═══════════ ATR Change Filter ═══════════"
useATRChangeFilter = input.bool(false, "Use ATR Change Filter", group=atr_change_group)
atr_change_period = input.int(20, "ATR Period for Comparison", minval=5, maxval=100, group=atr_change_group)
atr_change_threshold = input.float(10.0, "Min ATR Change %", minval=1.0, maxval=50.0, step=1.0, group=atr_change_group)

// ===============================
// BLOCK IF WORSE THAN
// ===============================
block_filter_group = "═══════════ Block Filter ═══════════"
useBlockIfWorse = input.bool(false, "Block if Worse Than", group=block_filter_group)
blockIfWorsePercent = input.float(0.5, "Block if price moved X% in our direction", minval=0.1, maxval=5.0, step=0.1, group=block_filter_group)

// ===============================
// PINBAR + MA SIGNAL
// ===============================
pinbar_group = "═══════════ PinBar+MA ═══════════"
usePinBarMA = input.bool(false, "Use PinBar + MA Signal", group=pinbar_group)
pinbar_ma1_length = input.int(10, "MA1 Length", minval=2, maxval=100, group=pinbar_group)
pinbar_ma2_length = input.int(20, "MA2 Length", minval=2, maxval=100, group=pinbar_group)
pinbar_ma3_length = input.int(50, "MA3 Length", minval=2, maxval=100, group=pinbar_group)
pinbar_ratio = input.float(2.0, "Pin Bar Ratio", minval=1.5, maxval=5.0, step=0.1, group=pinbar_group)

// ===============================
// SUPERTREND FILTER
// ===============================
st_group = "═══════════ Supertrend ═══════════"
useSupertrend = input.bool(false, "Use Supertrend Filter", group=st_group)
supertrend_period = input.int(10, "Supertrend Period", minval=1, maxval=50, group=st_group)
supertrend_factor = input.float(3.0, "Supertrend Factor", minval=0.5, maxval=10.0, step=0.1, group=st_group)
st_signal_type = input.string("Trend Filter", "SuperTrend Signal Type", options=["Trend Change", "Trend Filter"], group=st_group)

// ===============================
// CONSOLIDATION ZONES
// ===============================
consol_group = "═══════════ Consolidation ═══════════"
useConsolidation = input.bool(false, "Use Consolidation Zones", group=consol_group)
consolidation_length = input.int(20, "Consolidation Length", minval=5, maxval=100, group=consol_group)
consolidation_range = input.float(1.0, "Max Range % for Consolidation", minval=0.1, maxval=5.0, step=0.1, group=consol_group)

// ===============================
// MOVING AVERAGES
// ===============================
ma_group = "═══════════ Moving Averages ═══════════"
useMA = input.bool(false, "Use Moving Averages", group=ma_group)
ma_fast_length = input.int(10, "Fast MA Length", minval=2, maxval=200, group=ma_group)
ma_slow_length = input.int(30, "Slow MA Length", minval=2, maxval=200, group=ma_group)
ma_fast_type = input.string("EMA", "Fast MA Type", options=["SMA", "EMA", "RMA", "WMA", "HMA", "VWMA", "TEMA", "DEMA"], group=ma_group)
ma_slow_type = input.string("EMA", "Slow MA Type", options=["SMA", "EMA", "RMA", "WMA", "HMA", "VWMA", "TEMA", "DEMA"], group=ma_group)
ma_signal_type = input.string("Cross", "MA Signal Type", options=["Cross", "Direction", "Both Direction Same"], group=ma_group)
ma_signal_memory = input.bool(false, "Activate Signal Memory", group=ma_group)
ma_memory_bars = input.int(5, "Signal Memory Bars", minval=1, maxval=20, group=ma_group)

// ===============================
// CHANNELS (BB/KC)
// ===============================
channel_group = "═══════════ Channels ═══════════"
useChannels = input.bool(false, "Use Channels", group=channel_group)
channel_type = input.string("Bollinger Bands", "Channel Type", options=["Bollinger Bands", "Keltner Channel"], group=channel_group)
channel_length = input.int(20, "Channel Length", minval=5, maxval=100, group=channel_group)
channel_multiplier = input.float(2.0, "Channel Multiplier", minval=0.5, maxval=5.0, step=0.1, group=channel_group)
channel_signal_type = input.string("Touch", "Channel Signal", options=["Touch", "Close Outside", "Breakout"], group=channel_group)

// ===============================
// RSI SETTINGS - EXPANDED (3 instances)
// ===============================
rsi_group = "═══════════ RSI Instances ═══════════"
// RSI 1
useRSI1 = input.bool(false, "Use RSI #1", group=rsi_group)
rsi1_length = input.int(14, "RSI #1 Length", minval=2, maxval=100, group=rsi_group)
rsi1_overbought = input.float(70, "RSI #1 Overbought", minval=50, maxval=90, group=rsi_group)
rsi1_oversold = input.float(30, "RSI #1 Oversold", minval=10, maxval=50, group=rsi_group)
rsi1_condition = input.string("Oversold", "RSI #1 Long Condition", options=["Oversold", "Above 50", "Custom Range", "Cross Level Up", "Cross Level Down", "Rising/Falling"], group=rsi_group)
rsi1_custom_min = input.float(30, "RSI #1 Custom Min", minval=0, maxval=100, group=rsi_group)
rsi1_custom_max = input.float(70, "RSI #1 Custom Max", minval=0, maxval=100, group=rsi_group)
rsi1_use_btc_source = input.bool(false, "RSI #1 Use BTCUSDT Source", group=rsi_group)
rsi1_signal_memory = input.bool(false, "RSI #1 Signal Memory", group=rsi_group)
rsi1_memory_bars = input.int(5, "RSI #1 Memory Bars", minval=1, maxval=20, group=rsi_group)
rsi1_direction_period = input.int(3, "RSI #1 Direction Period", minval=1, maxval=10, group=rsi_group)

// RSI 2
useRSI2 = input.bool(false, "Use RSI #2", group=rsi_group)
rsi2_length = input.int(21, "RSI #2 Length", minval=2, maxval=100, group=rsi_group)
rsi2_overbought = input.float(75, "RSI #2 Overbought", minval=50, maxval=90, group=rsi_group)
rsi2_oversold = input.float(25, "RSI #2 Oversold", minval=10, maxval=50, group=rsi_group)
rsi2_condition = input.string("Oversold", "RSI #2 Long Condition", options=["Oversold", "Above 50", "Custom Range", "Cross Level Up", "Cross Level Down", "Rising/Falling"], group=rsi_group)
rsi2_custom_min = input.float(25, "RSI #2 Custom Min", minval=0, maxval=100, group=rsi_group)
rsi2_custom_max = input.float(75, "RSI #2 Custom Max", minval=0, maxval=100, group=rsi_group)
rsi2_use_btc_source = input.bool(false, "RSI #2 Use BTCUSDT Source", group=rsi_group)
rsi2_signal_memory = input.bool(false, "RSI #2 Signal Memory", group=rsi_group)
rsi2_memory_bars = input.int(5, "RSI #2 Memory Bars", minval=1, maxval=20, group=rsi_group)
rsi2_direction_period = input.int(3, "RSI #2 Direction Period", minval=1, maxval=10, group=rsi_group)

// RSI 3
useRSI3 = input.bool(false, "Use RSI #3", group=rsi_group)
rsi3_length = input.int(7, "RSI #3 Length", minval=2, maxval=100, group=rsi_group)
rsi3_overbought = input.float(80, "RSI #3 Overbought", minval=50, maxval=90, group=rsi_group)
rsi3_oversold = input.float(20, "RSI #3 Oversold", minval=10, maxval=50, group=rsi_group)
rsi3_condition = input.string("Oversold", "RSI #3 Long Condition", options=["Oversold", "Above 50", "Custom Range", "Cross Level Up", "Cross Level Down", "Rising/Falling"], group=rsi_group)
rsi3_custom_min = input.float(20, "RSI #3 Custom Min", minval=0, maxval=100, group=rsi_group)
rsi3_custom_max = input.float(80, "RSI #3 Custom Max", minval=0, maxval=100, group=rsi_group)
rsi3_use_btc_source = input.bool(false, "RSI #3 Use BTCUSDT Source", group=rsi_group)
rsi3_signal_memory = input.bool(false, "RSI #3 Signal Memory", group=rsi_group)
rsi3_memory_bars = input.int(5, "RSI #3 Memory Bars", minval=1, maxval=20, group=rsi_group)
rsi3_direction_period = input.int(3, "RSI #3 Direction Period", minval=1, maxval=10, group=rsi_group)

// ===============================
// SUPERTREND EXPANDED (3 instances)
// ===============================
st_expanded_group = "═══════════ SuperTrend Instances ═══════════"
// ST 1
useST1 = input.bool(false, "Use SuperTrend #1", group=st_expanded_group)
st1_period = input.int(10, "ST #1 Period", minval=1, maxval=50, group=st_expanded_group)
st1_factor = input.float(3.0, "ST #1 Factor", minval=0.5, maxval=10.0, step=0.1, group=st_expanded_group)
st1_use_btc_source = input.bool(false, "ST #1 Use BTCUSDT Source", group=st_expanded_group)
st1_signal_type = input.string("Trend Filter", "ST #1 Signal Type", options=["Trend Change", "Trend Filter"], group=st_expanded_group)
st1_signal_memory = input.bool(false, "ST #1 Signal Memory", group=st_expanded_group)
st1_memory_bars = input.int(5, "ST #1 Memory Bars", minval=1, maxval=20, group=st_expanded_group)

// ST 2
useST2 = input.bool(false, "Use SuperTrend #2", group=st_expanded_group)
st2_period = input.int(14, "ST #2 Period", minval=1, maxval=50, group=st_expanded_group)
st2_factor = input.float(2.5, "ST #2 Factor", minval=0.5, maxval=10.0, step=0.1, group=st_expanded_group)
st2_use_btc_source = input.bool(false, "ST #2 Use BTCUSDT Source", group=st_expanded_group)
st2_signal_type = input.string("Trend Filter", "ST #2 Signal Type", options=["Trend Change", "Trend Filter"], group=st_expanded_group)
st2_signal_memory = input.bool(false, "ST #2 Signal Memory", group=st_expanded_group)
st2_memory_bars = input.int(5, "ST #2 Memory Bars", minval=1, maxval=20, group=st_expanded_group)

// ST 3
useST3 = input.bool(false, "Use SuperTrend #3", group=st_expanded_group)
st3_period = input.int(21, "ST #3 Period", minval=1, maxval=50, group=st_expanded_group)
st3_factor = input.float(2.0, "ST #3 Factor", minval=0.5, maxval=10.0, step=0.1, group=st_expanded_group)
st3_use_btc_source = input.bool(false, "ST #3 Use BTCUSDT Source", group=st_expanded_group)
st3_signal_type = input.string("Trend Filter", "ST #3 Signal Type", options=["Trend Change", "Trend Filter"], group=st_expanded_group)
st3_signal_memory = input.bool(false, "ST #3 Signal Memory", group=st_expanded_group)
st3_memory_bars = input.int(5, "ST #3 Memory Bars", minval=1, maxval=20, group=st_expanded_group)

// ===============================
// RVI SETTINGS
// ===============================
rvi_group = "═══════════ RVI ═══════════"
useRVI = input.bool(false, "Use RVI", group=rvi_group)
rvi_length = input.int(10, "RVI Length", minval=2, maxval=100, group=rvi_group)
rvi_overbought = input.float(0.4, "RVI Overbought", minval=0.1, maxval=0.9, step=0.1, group=rvi_group)
rvi_oversold = input.float(-0.4, "RVI Oversold", minval=-0.9, maxval=-0.1, step=0.1, group=rvi_group)
rvi_signal_type = input.string("Level Filter", "RVI Signal Type", options=["Level Filter", "Cross Level", "Rising/Falling", "Zero Cross"], group=rvi_group)
rvi_signal_memory = input.bool(false, "RVI Signal Memory", group=rvi_group)
rvi_memory_bars = input.int(5, "RVI Memory Bars", minval=1, maxval=20, group=rvi_group)
rvi_direction_period = input.int(3, "RVI Direction Period", minval=1, maxval=10, group=rvi_group)

// ===============================
// MFI SETTINGS
// ===============================
mfi_group = "═══════════ MFI ═══════════"
useMFI = input.bool(false, "Use MFI", group=mfi_group)
mfi_length = input.int(14, "MFI Length", minval=2, maxval=100, group=mfi_group)
mfi_overbought = input.float(80, "MFI Overbought", minval=50, maxval=90, group=mfi_group)
mfi_oversold = input.float(20, "MFI Oversold", minval=10, maxval=50, group=mfi_group)
mfi_signal_type = input.string("Level Filter", "MFI Signal Type", options=["Level Filter", "Cross Level", "Rising/Falling"], group=mfi_group)
mfi_signal_memory = input.bool(false, "MFI Signal Memory", group=mfi_group)
mfi_memory_bars = input.int(5, "MFI Memory Bars", minval=1, maxval=20, group=mfi_group)
mfi_direction_period = input.int(3, "MFI Direction Period", minval=1, maxval=10, group=mfi_group)

// ===============================
// STOCHASTIC SETTINGS
// ===============================
stoch_group = "═══════════ Stochastic ═══════════"
useStochastic = input.bool(false, "Use Stochastic", group=stoch_group)
stoch_k_length = input.int(14, "Stochastic %K Length", minval=1, maxval=100, group=stoch_group)
stoch_k_smooth = input.int(1, "Stochastic %K Smoothing", minval=1, maxval=10, group=stoch_group)
stoch_d_smooth = input.int(3, "Stochastic %D Smoothing", minval=1, maxval=10, group=stoch_group)
stoch_overbought = input.float(80, "Stochastic Overbought", minval=50, maxval=100, group=stoch_group)
stoch_oversold = input.float(20, "Stochastic Oversold", minval=0, maxval=50, group=stoch_group)
stoch_signal_type = input.string("Oversold Cross", "Stochastic Signal Type", options=["Oversold Cross", "Overbought Cross", "K-D Cross", "Level Filter", "Rising/Falling"], group=stoch_group)
stoch_signal_memory = input.bool(false, "Stochastic Signal Memory", group=stoch_group)
stoch_memory_bars = input.int(5, "Stochastic Memory Bars", minval=1, maxval=20, group=stoch_group)
stoch_direction_period = input.int(3, "Stochastic Direction Period", minval=1, maxval=10, group=stoch_group)

// ===============================
// CCI SETTINGS
// ===============================
cci_group = "═══════════ CCI ═══════════"
useCCI = input.bool(false, "Use CCI", group=cci_group)
cci_length = input.int(20, "CCI Length", minval=5, maxval=200, group=cci_group)
cci_overbought = input.float(100, "CCI Overbought", minval=50, maxval=200, group=cci_group)
cci_oversold = input.float(-100, "CCI Oversold", minval=-200, maxval=-50, group=cci_group)
cci_signal_type = input.string("Level Filter", "CCI Signal Type", options=["Level Filter", "Cross Level", "Rising/Falling", "Zero Cross"], group=cci_group)
cci_signal_memory = input.bool(false, "CCI Signal Memory", group=cci_group)
cci_memory_bars = input.int(5, "CCI Memory Bars", minval=1, maxval=20, group=cci_group)
cci_direction_period = input.int(3, "CCI Direction Period", minval=1, maxval=10, group=cci_group)

// ===============================
// MOMENTUM SETTINGS
// ===============================
mom_group = "═══════════ Momentum ═══════════"
useMomentum = input.bool(false, "Use Momentum", group=mom_group)
momentum_length = input.int(10, "Momentum Length", minval=2, maxval=100, group=mom_group)
momentum_overbought = input.float(0.5, "Momentum Overbought", minval=0.1, maxval=2.0, step=0.1, group=mom_group)
momentum_oversold = input.float(-0.5, "Momentum Oversold", minval=-2.0, maxval=-0.1, step=0.1, group=mom_group)
momentum_signal_type = input.string("Level Filter", "Momentum Signal Type", options=["Level Filter", "Cross Level", "Rising/Falling", "Zero Cross"], group=mom_group)
momentum_signal_memory = input.bool(false, "Momentum Signal Memory", group=mom_group)
momentum_memory_bars = input.int(5, "Momentum Memory Bars", minval=1, maxval=20, group=mom_group)
momentum_direction_period = input.int(3, "Momentum Direction Period", minval=1, maxval=10, group=mom_group)

// ===============================
// DYNAMIC RSI
// ===============================
drsi_group = "═══════════ Dynamic RSI ═══════════"
useDynamicRSI = input.bool(false, "Use Dynamic RSI", group=drsi_group)
drsi_length = input.int(14, "Dynamic RSI Length", minval=2, maxval=100, group=drsi_group)
drsi_band_length = input.int(20, "Band Length", minval=5, maxval=100, group=drsi_group)
drsi_band_mult = input.float(2.0, "Band Multiplier", minval=1.0, maxval=5.0, step=0.1, group=drsi_group)

// ===============================
// DYNAMIC MFI
// ===============================
dmfi_group = "═══════════ Dynamic MFI ═══════════"
useDynamicMFI = input.bool(false, "Use Dynamic MFI", group=dmfi_group)
dmfi_length = input.int(14, "Dynamic MFI Length", minval=2, maxval=100, group=dmfi_group)
dmfi_band_length = input.int(20, "Band Length", minval=5, maxval=100, group=dmfi_group)
dmfi_band_mult = input.float(2.0, "Band Multiplier", minval=1.0, maxval=5.0, step=0.1, group=dmfi_group)

// ===============================
// SMI ERGODIC OSCILLATOR
// ===============================
smi_group = "═══════════ SMI Ergodic ═══════════"
useSMIO = input.bool(false, "Use SMI Ergodic", group=smi_group)
smio_short_length = input.int(5, "Short Length", minval=2, maxval=50, group=smi_group)
smio_long_length = input.int(20, "Long Length", minval=5, maxval=100, group=smi_group)
smio_signal_length = input.int(5, "Signal Length", minval=2, maxval=50, group=smi_group)
smio_overbought = input.float(0.5, "Overbought", minval=0.1, maxval=1.0, step=0.1, group=smi_group)
smio_oversold = input.float(-0.5, "Oversold", minval=-1.0, maxval=-0.1, step=0.1, group=smi_group)

// ===============================
// DMI SETTINGS
// ===============================
dmi_group = "═══════════ DMI ═══════════"
useDMI = input.bool(false, "Use DMI", group=dmi_group)
dmi_length = input.int(14, "DMI Length", minval=5, maxval=50, group=dmi_group)
dmi_adx_threshold = input.float(25, "ADX Threshold", minval=10, maxval=50, group=dmi_group)
dmi_signal_type = input.string("DI Cross", "DMI Signal", options=["DI Cross", "ADX Level", "Both", "ADX Rising"], group=dmi_group)
dmi_signal_memory = input.bool(false, "DMI Signal Memory", group=dmi_group)
dmi_memory_bars = input.int(5, "DMI Memory Bars", minval=1, maxval=20, group=dmi_group)
dmi_adx_rising = input.bool(false, "ADX Rising Signal", group=dmi_group)
dmi_adx_period = input.int(3, "ADX Rising Period", minval=1, maxval=10, group=dmi_group)

// ===============================
// CHAIKIN MONEY FLOW
// ===============================
chaikin_group = "═══════════ Chaikin MF ═══════════"
useChaikin = input.bool(false, "Use Chaikin Money Flow", group=chaikin_group)
chaikin_length = input.int(20, "Chaikin Length", minval=5, maxval=100, group=chaikin_group)
chaikin_overbought = input.float(0.2, "Overbought", minval=0.1, maxval=0.5, step=0.05, group=chaikin_group)
chaikin_oversold = input.float(-0.2, "Oversold", minval=-0.5, maxval=-0.1, step=0.05, group=chaikin_group)
chaikin_use_zero = input.bool(true, "Use Zero Cross Signal", group=chaikin_group)

// ===============================
// BALANCE OF POWER
// ===============================
bop_group = "═══════════ Balance of Power ═══════════"
useBOP = input.bool(false, "Use Balance of Power", group=bop_group)
bop_smooth_length = input.int(14, "Smoothing Length", minval=1, maxval=50, group=bop_group)
bop_overbought = input.float(0.5, "Overbought", minval=0.1, maxval=1.0, step=0.1, group=bop_group)
bop_oversold = input.float(-0.5, "Oversold", minval=-1.0, maxval=-0.1, step=0.1, group=bop_group)
bop_use_zero = input.bool(true, "Use Zero Cross Signal", group=bop_group)

// ===============================
// MACD SETTINGS
// ===============================
macd_group = "═══════════ MACD ═══════════"
useMACD = input.bool(false, "Use MACD", group=macd_group)
macd_fast_length = input.int(12, "Fast Length", minval=2, maxval=50, group=macd_group)
macd_slow_length = input.int(26, "Slow Length", minval=5, maxval=100, group=macd_group)
macd_signal_length = input.int(9, "Signal Length", minval=2, maxval=50, group=macd_group)
macd_signal_type = input.string("Signal Cross", "MACD Signal", options=["Signal Cross", "Zero Cross", "Both"], group=macd_group)
macd_signal_memory = input.bool(true, "Activate Signal Memory", group=macd_group)
macd_memory_bars = input.int(5, "Signal Memory Bars", minval=1, maxval=20, group=macd_group)

// ===============================
// LEVELS (SUPPORT/RESISTANCE)
// ===============================
levels_group = "═══════════ Levels ═══════════"
useLevels = input.bool(false, "Use Levels", group=levels_group)
level_lookback = input.int(50, "Lookback Period", minval=10, maxval=200, group=levels_group)
level_proximity = input.float(0.5, "Proximity to Level %", minval=0.1, maxval=2.0, step=0.1, group=levels_group)
level_min_touches = input.int(3, "Min Touches for Level", minval=2, maxval=10, group=levels_group)

// ===============================
// QQE SIGNALS
// ===============================
qqe_group = "═══════════ QQE ═══════════"
useQQE = input.bool(false, "Use QQE Signals", group=qqe_group)
qqe_rsi_length = input.int(14, "RSI Length", minval=2, maxval=100, group=qqe_group)
qqe_smoothing = input.int(5, "Smoothing", minval=1, maxval=50, group=qqe_group)
qqe_factor = input.float(4.236, "QQE Factor", minval=1.0, maxval=10.0, step=0.1, group=qqe_group)

// ===============================
// DIVERGENCES
// ===============================
div_group = "═══════════ Divergences ═══════════"
useDivergence = input.bool(false, "Use Divergences", group=div_group)
div_lookback = input.int(50, "Lookback Period", minval=10, maxval=100, group=div_group)
div_rsi = input.bool(true, "Check RSI Divergence", group=div_group)
div_macd = input.bool(true, "Check MACD Divergence", group=div_group)
div_mfi = input.bool(true, "Check MFI Divergence", group=div_group)
div_cci = input.bool(true, "Check CCI Divergence", group=div_group)
div_momentum = input.bool(true, "Check Momentum Divergence", group=div_group)
div_obv = input.bool(true, "Check OBV Divergence", group=div_group)

// ===============================
// CANDLE PATTERNS
// ===============================
candle_group = "═══════════ Candle Patterns ═══════════"
useCandlePatterns = input.bool(false, "Use Candle Patterns", group=candle_group)
use_hammer = input.bool(true, "Hammer/Hanging Man", group=candle_group)
use_engulfing = input.bool(true, "Engulfing", group=candle_group)
use_doji = input.bool(true, "Doji", group=candle_group)
use_morning_evening_star = input.bool(true, "Morning/Evening Star", group=candle_group)
use_three_soldiers_crows = input.bool(true, "Three Soldiers/Crows", group=candle_group)

// ===============================
// LINEAR REGRESSION CHANNEL
// ===============================
lrc_group = "═══════════ LRC ═══════════"
useLRC = input.bool(false, "Use Linear Regression Channel", group=lrc_group)
lrc_length = input.int(100, "LRC Length", minval=20, maxval=500, group=lrc_group)
lrc_deviation = input.float(2.0, "Deviation", minval=0.5, maxval=5.0, step=0.1, group=lrc_group)

// ===============================
// EXTERNAL INDICATORS
// ===============================
ext_group = "═══════════ External ═══════════"
useExternal = input.bool(false, "Use External Indicator", group=ext_group)
external_source = input.source(close, "External Source", group=ext_group)
external_condition = input.string("Above", "Condition", options=["Above", "Below", "Cross Up", "Cross Down"], group=ext_group)
external_level = input.float(0, "Level", group=ext_group)

// ===============================
// BTCUSDT SOURCE DATA
// ===============================
btc_group = "═══════════ BTCUSDT Data ═══════════"
btc_symbol = input.symbol("BINANCE:BTCUSDT", "BTC Symbol", group=btc_group)
btc_close = request.security(btc_symbol, timeframe.period, close)
btc_high = request.security(btc_symbol, timeframe.period, high)
btc_low = request.security(btc_symbol, timeframe.period, low)
btc_open = request.security(btc_symbol, timeframe.period, open)
btc_volume = request.security(btc_symbol, timeframe.period, volume)

// ===============================
// CLOSE CONDITIONS
// ===============================
close_group = "═══════════ Close Signals ═══════════"
close_parabolic_sar = input.bool(false, "Use Parabolic SAR Close", group=close_group)
close_lrc = input.bool(false, "Use LRC Close Signal", group=close_group)
close_bb_kc = input.bool(false, "Use Channel Close Signal", group=close_group)
close_qqe = input.bool(false, "Use QQE Close Signal", group=close_group)
close_rsi = input.bool(false, "Use RSI Close Signal", group=close_group)
close_ma_cross = input.bool(false, "Use MA Cross Close Signal", group=close_group)
close_stoch = input.bool(false, "Use Stochastic Close Signal", group=close_group)
close_only_profit = input.bool(false, "Close Only in Profit", group=close_group)

// Parabolic SAR settings
sar_start = input.float(0.02, "SAR Start", minval=0.01, maxval=0.1, step=0.01, group=close_group)
sar_increment = input.float(0.02, "SAR Increment", minval=0.01, maxval=0.1, step=0.01, group=close_group)
sar_maximum = input.float(0.2, "SAR Maximum", minval=0.1, maxval=1.0, step=0.1, group=close_group)

// ===============================
// CALCULATION FUNCTIONS - FIXED
// ===============================
// Bollinger Bands
bollinger_bands(src, length, mult) =>
    basis = ta.sma(src, length)
    dev = mult * ta.stdev(src, length)
    [basis + dev, basis, basis - dev]

// Keltner Channel
keltner_channel(src, length, mult) =>
    basis = ta.ema(src, length)
    range_val = ta.atr(length)
    [basis + range_val * mult, basis, basis - range_val * mult]

// FIXED SuperTrend Function - returns state, no global var modification
calculate_supertrend(factor, period, use_btc, prev_direction, prev_supertrend) =>
    src_high = use_btc ? btc_high : high
    src_low = use_btc ? btc_low : low
    src_close = use_btc ? btc_close : close
    src_hl2 = (src_high + src_low) / 2
    
    atr_val = ta.atr(period)
    upperBand = src_hl2 + factor * atr_val
    lowerBand = src_hl2 - factor * atr_val
    
    prevLowerBand = nz(lowerBand[1])
    prevUpperBand = nz(upperBand[1])
    
    lb = lowerBand > prevLowerBand or src_close[1] < prevLowerBand ? lowerBand : prevLowerBand
    ub = upperBand < prevUpperBand or src_close[1] > prevUpperBand ? upperBand : prevUpperBand
    
    direction = 1
    superTrend = 0.0
    
    if na(prev_supertrend)
        direction := 1
        superTrend := lb
    else
        if prev_supertrend == prevUpperBand
            direction := src_close <= ub ? -1 : 1
        else
            direction := src_close >= lb ? 1 : -1
        
        superTrend := direction == -1 ? ub : lb
    
    [superTrend, direction]

// Individual SuperTrend state variables for each instance
var float st_direction = 1
var float st_supertrend = na
var float st1_direction = 1
var float st1_supertrend = na
var float st2_direction = 1
var float st2_supertrend = na
var float st3_direction = 1
var float st3_supertrend = na

// RVI Calculation
calculate_rvi(length) =>
    numerator = ta.sma(close - open, length)
    denominator = ta.sma(high - low, length)
    rvi_val = denominator == 0 ? 0 : numerator / denominator
    signal = ta.sma(rvi_val, 4)
    [rvi_val, signal]

// SMI Ergodic Oscillator
smi_ergodic(shortLength, longLength, signalLength) =>
    price = close
    highestHigh = ta.highest(high, longLength)
    lowestLow = ta.lowest(low, longLength)
    
    priceChangeEMA = ta.ema(ta.ema(price - 0.5 * (highestHigh + lowestLow), shortLength), shortLength)
    rangeEMA = ta.ema(ta.ema(0.5 * (highestHigh - lowestLow), shortLength), shortLength)
    
    smi_val = rangeEMA != 0 ? priceChangeEMA / rangeEMA : 0
    signal = ta.ema(smi_val, signalLength)
    
    [smi_val, signal]

// QQE Calculation - FIXED: Functions cannot modify global var variables
var float qqe_longband = 0.0
var float qqe_shortband = 0.0
var int qqe_trend_state = 0

calculate_qqe(src, length, smoothing, factor, prev_longband, prev_shortband, prev_trend) =>
    rsi_val = ta.rsi(src, length)
    rsi_ma = ta.ema(rsi_val, smoothing)
    
    atr_rsi = ta.ema(math.abs(rsi_ma[1] - rsi_ma), smoothing)
    dar = ta.ema(atr_rsi, smoothing) * factor
    
    newlongband = rsi_ma - dar
    newshortband = rsi_ma + dar
    
    longband_result = 0.0
    shortband_result = 0.0
    
    if rsi_ma[1] > prev_longband and rsi_ma > prev_longband
        longband_result := math.max(prev_longband, newlongband)
    else
        longband_result := newlongband
    
    if rsi_ma[1] < prev_shortband and rsi_ma < prev_shortband
        shortband_result := math.min(prev_shortband, newshortband)
    else
        shortband_result := newshortband
    
    cross_1 = ta.cross(longband_result, rsi_ma)
    cross_2 = ta.cross(rsi_ma, shortband_result)
    
    trend_result = 0
    if cross_2
        trend_result := 1
    else if cross_1
        trend_result := -1
    else
        trend_result := prev_trend
    
    [rsi_ma, longband_result, shortband_result, trend_result]

// Dynamic Bands
dynamic_bands(value, length, mult) =>
    basis = ta.sma(value, length)
    dev = mult * ta.stdev(value, length)
    [basis + dev, basis - dev]

// Balance of Power
calculate_bop() =>
    bop_raw = high - low == 0 ? 0 : (close - open) / (high - low)
    ta.sma(bop_raw, bop_smooth_length)

// Chaikin Money Flow
calculate_cmf(length) =>
    mfv = ((close - low) - (high - close)) / (high - low) * volume
    ta.sma(mfv, length) / ta.sma(volume, length)

// ENHANCED Divergence Detection Function - PROFESSIONAL IMPLEMENTATION
detect_divergence_professional(price_series, indicator_series, lookback, min_pivot_distance) =>
    // Find significant pivots with minimum distance requirement
    ph = ta.pivothigh(price_series, lookback, lookback)
    pl = ta.pivotlow(price_series, lookback, lookback)
    ih = ta.pivothigh(indicator_series, lookback, lookback)
    il = ta.pivotlow(indicator_series, lookback, lookback)
    
    // Store recent significant highs and lows with bars
    var float last_price_high = na
    var float last_price_low = na
    var float last_indicator_high = na
    var float last_indicator_low = na
    var int last_high_bar = na
    var int last_low_bar = na
    
    // Update last significant pivot high
    if not na(ph) and not na(ih)
        if na(last_high_bar) or (bar_index - last_high_bar) >= min_pivot_distance
            if ph != last_price_high or ih != last_indicator_high
                last_price_high := ph
                last_indicator_high := ih
                last_high_bar := bar_index
    
    // Update last significant pivot low  
    if not na(pl) and not na(il)
        if na(last_low_bar) or (bar_index - last_low_bar) >= min_pivot_distance
            if pl != last_price_low or il != last_indicator_low
                last_price_low := pl
                last_indicator_low := il
                last_low_bar := bar_index
    
    // Detect divergences only with sufficient history
    bull_div = false
    bear_div = false
    
    // Bullish divergence: price makes lower low, indicator makes higher low
    if not na(pl) and not na(il) and not na(last_price_low) and not na(last_indicator_low)
        if (bar_index - last_low_bar) >= min_pivot_distance
            price_lower_low = pl < last_price_low
            indicator_higher_low = il > last_indicator_low
            bull_div := price_lower_low and indicator_higher_low
    
    // Bearish divergence: price makes higher high, indicator makes lower high
    if not na(ph) and not na(ih) and not na(last_price_high) and not na(last_indicator_high)
        if (bar_index - last_high_bar) >= min_pivot_distance
            price_higher_high = ph > last_price_high
            indicator_lower_high = ih < last_indicator_high
            bear_div := price_higher_high and indicator_lower_high
    
    [bull_div, bear_div]

// Enhanced Divergence Settings
div_pivot_lookback = input.int(5, "Divergence Pivot Lookback", minval=2, maxval=15, group=div_group)
div_min_pivot_distance = input.int(10, "Min Pivot Distance", minval=5, maxval=50, group=div_group)
div_signal_memory = input.bool(true, "Divergence Signal Memory", group=div_group)
div_memory_bars = input.int(10, "Divergence Memory Bars", minval=5, maxval=30, group=div_group)

// Candle Pattern Functions
f_isHammer() =>
    body = math.abs(close - open)
    lower_shadow = open > close ? close - low : open - low
    upper_shadow = open > close ? high - open : high - close
    lower_shadow >= body * 2 and upper_shadow <= body * 0.5

f_isEngulfingBull() =>
    close[1] < open[1] and close > open and open <= close[1] and close >= open[1]

f_isEngulfingBear() =>
    close[1] > open[1] and close < open and open >= close[1] and close <= open[1]

f_isDoji() =>
    body = math.abs(close - open)
    avg_body = ta.sma(math.abs(close - open), 20)
    body <= avg_body * 0.1

f_isMorningStar() =>
    close[2] < open[2] and math.abs(close[1] - open[1]) < (high[1] - low[1]) * 0.3 and close > open and close > (open[2] + close[2]) / 2

f_isEveningStar() =>
    close[2] > open[2] and math.abs(close[1] - open[1]) < (high[1] - low[1]) * 0.3 and close < open and close < (open[2] + close[2]) / 2

f_isThreeWhiteSoldiers() =>
    close > open and close[1] > open[1] and close[2] > open[2] and close > close[1] and close[1] > close[2] and open < close[1] and open[1] < close[2]

f_isThreeBlackCrows() =>
    close < open and close[1] < open[1] and close[2] < open[2] and close < close[1] and close[1] < close[2] and open > close[1] and open[1] > close[2]

// ===============================
// INDICATOR CALCULATIONS - FIXED ORDER
// ===============================
// ATR calculations
atr_val = ta.atr(14)
atr_sl_val = ta.atr(atr_sl_length)
atr_tp_val = ta.atr(atr_tp_length)

// Volume and Volatility
volume_avg = ta.sma(volume, volume_length)
volatility = ta.stdev(close, vol_length) / ta.sma(close, vol_length) * 100

// Parabolic SAR
sar_val = ta.sar(sar_start, sar_increment, sar_maximum)

// MA calculations - FIXED: moved before cross calculations
ma_fast_val = ma_function(close, ma_fast_length, ma_fast_type)
ma_slow_val = ma_function(close, ma_slow_length, ma_slow_type)

// MA Cross calculations - FIXED: moved after MA value calculations
ma_cross_under = ta.crossunder(ma_fast_val, ma_slow_val)
ma_cross_over = ta.crossover(ma_fast_val, ma_slow_val)

// RSI calculations with BTC source support
rsi1_source = rsi1_use_btc_source ? btc_close : close
rsi1_value = ta.rsi(rsi1_source, rsi1_length)

rsi2_source = rsi2_use_btc_source ? btc_close : close
rsi2_value = ta.rsi(rsi2_source, rsi2_length)

rsi3_source = rsi3_use_btc_source ? btc_close : close
rsi3_value = ta.rsi(rsi3_source, rsi3_length)

// RSI cross calculations - FIXED: moved after RSI value calculations
rsi1_cross_up = ta.crossover(rsi1_value, rsi1_oversold)
rsi1_cross_down = ta.crossunder(rsi1_value, rsi1_overbought)
rsi2_cross_up = ta.crossover(rsi2_value, rsi2_oversold)
rsi2_cross_down = ta.crossunder(rsi2_value, rsi2_overbought)
rsi3_cross_up = ta.crossover(rsi3_value, rsi3_oversold)
rsi3_cross_down = ta.crossunder(rsi3_value, rsi3_overbought)

// SuperTrend calculations - FIXED: using corrected function with state management
[st1_line, st1_dir] = calculate_supertrend(st1_factor, st1_period, st1_use_btc_source, st1_direction, st1_supertrend)
st1_direction := st1_dir
st1_supertrend := st1_line

[st2_line, st2_dir] = calculate_supertrend(st2_factor, st2_period, st2_use_btc_source, st2_direction, st2_supertrend)
st2_direction := st2_dir
st2_supertrend := st2_line

[st3_line, st3_dir] = calculate_supertrend(st3_factor, st3_period, st3_use_btc_source, st3_direction, st3_supertrend)
st3_direction := st3_dir
st3_supertrend := st3_line

// Channels
[bb_upper, bb_basis, bb_lower] = bollinger_bands(close, channel_length, channel_multiplier)
[kc_upper, kc_basis, kc_lower] = keltner_channel(close, channel_length, channel_multiplier)

channel_upper = channel_type == "Bollinger Bands" ? bb_upper : kc_upper
channel_basis = channel_type == "Bollinger Bands" ? bb_basis : kc_basis
channel_lower = channel_type == "Bollinger Bands" ? bb_lower : kc_lower

// Legacy Supertrend calculation - FIXED with all parameters
[st_line, st_direction_new] = calculate_supertrend(supertrend_factor, supertrend_period, false, st_direction, st_supertrend)
st_direction := st_direction_new
st_supertrend := st_line
st_trend = st_direction_new  // For compatibility with existing code

// QQE calculation with proper var assignment in global scope
[qqe_rsi, new_qqe_long, new_qqe_short, new_qqe_trend] = calculate_qqe(close, qqe_rsi_length, qqe_smoothing, qqe_factor, qqe_longband, qqe_shortband, qqe_trend_state)

// Update global var variables outside the function
qqe_longband := new_qqe_long
qqe_shortband := new_qqe_short
qqe_trend_state := new_qqe_trend

// Return final values for use in signals
qqe_long = new_qqe_long
qqe_short = new_qqe_short
qqe_trend = new_qqe_trend

// RVI
[rvi_val, rvi_signal] = calculate_rvi(rvi_length)

// MFI
mfi_val = ta.mfi(hlc3, mfi_length)

// Stochastic - FIXED: Variable name conflict
stoch_k_raw = ta.stoch(close, high, low, stoch_k_length)
stoch_k_smoothed = ta.sma(stoch_k_raw, stoch_k_smooth)
stoch_d = ta.sma(stoch_k_smoothed, stoch_d_smooth)

// Stochastic cross calculations - FIXED: moved after stochastic calculations
stoch_cross_up = ta.crossover(stoch_k_smoothed, stoch_oversold)
stoch_cross_down = ta.crossunder(stoch_k_smoothed, stoch_overbought)

// CCI
cci_val = ta.cci(hlc3, cci_length)

// Momentum
momentum_val = ta.mom(close, momentum_length) / close[momentum_length]

// Dynamic RSI
[drsi_upper, drsi_lower] = dynamic_bands(rsi1_value, drsi_band_length, drsi_band_mult)

// Dynamic MFI
[dmfi_upper, dmfi_lower] = dynamic_bands(mfi_val, dmfi_band_length, dmfi_band_mult)

// SMI Ergodic
[smi_val, smi_signal] = smi_ergodic(smio_short_length, smio_long_length, smio_signal_length)

// DMI
[diplus, diminus, adx] = ta.dmi(dmi_length, dmi_length)

// DMI cross calculations - FIXED: moved after DMI calculations  
di_cross_long = ta.crossover(diplus, diminus)
di_cross_short = ta.crossunder(diplus, diminus)

// Chaikin Money Flow
cmf_val = calculate_cmf(chaikin_length)

// Balance of Power
bop_val = calculate_bop()

// CMF and BOP cross calculations - FIXED: moved after value calculations
cmf_cross_up = ta.crossover(cmf_val, 0)
cmf_cross_down = ta.crossunder(cmf_val, 0)
bop_cross_up = ta.crossover(bop_val, 0)
bop_cross_down = ta.crossunder(bop_val, 0)

// MACD
[macd_line, macd_signal_line, macd_hist] = ta.macd(close, macd_fast_length, macd_slow_length, macd_signal_length)

// MACD cross calculations - FIXED: moved after MACD calculations
macd_signal_cross_up = ta.crossover(macd_line, macd_signal_line)
macd_signal_cross_down = ta.crossunder(macd_line, macd_signal_line)
macd_zero_cross_up = ta.crossover(macd_line, 0)
macd_zero_cross_down = ta.crossunder(macd_line, 0)

// Linear Regression Channel
lrc_basis = ta.linreg(close, lrc_length, 0)
lrc_dev = ta.stdev(close, lrc_length)
lrc_upper = lrc_basis + lrc_deviation * lrc_dev
lrc_lower = lrc_basis - lrc_deviation * lrc_dev

// External Indicator cross calculations
external_cross_up = ta.crossover(external_source, external_level)
external_cross_down = ta.crossunder(external_source, external_level)

// ===============================
// SIGNAL MEMORY VARIABLES - EXPANDED FOR ALL INDICATORS
// ===============================
var int ma_cross_bar = 0
var int macd_cross_bar = 0

// RSI Signal Memory (3 instances)
var int rsi1_signal_bar = 0
var int rsi2_signal_bar = 0
var int rsi3_signal_bar = 0

// SuperTrend Signal Memory (3 instances + legacy)
var int st1_signal_bar = 0
var int st2_signal_bar = 0
var int st3_signal_bar = 0
var int supertrend_signal_bar = 0

// Oscillators Signal Memory
var int stoch_signal_bar = 0
var int dmi_signal_bar = 0
var int cci_signal_bar = 0
var int rvi_signal_bar = 0
var int mfi_signal_bar = 0
var int momentum_signal_bar = 0
var int smi_signal_bar = 0
var int bop_signal_bar = 0
var int cmf_signal_bar = 0
var int qqe_signal_bar = 0

// Pattern and Advanced Signal Memory
var int divergence_signal_bar = 0
var int candle_signal_bar = 0
var int lrc_signal_bar = 0
var int external_signal_bar = 0
var int channels_signal_bar = 0

// Filter Signal Memory
var int volume_signal_bar = 0
var int volatility_signal_bar = 0
var int highlow_signal_bar = 0
var int atr_change_signal_bar = 0
var int pinbar_signal_bar = 0

// ===============================
// SIGNAL CONDITIONS - FIXED SYNTAX
// ===============================
// Date and day filters
date_filter = year >= startYear and year <= stopYear

// Calculate blocked days step by step
is_monday_blocked = blockMo and dayofweek == dayofweek.monday
is_tuesday_blocked = blockTu and dayofweek == dayofweek.tuesday
is_wednesday_blocked = blockWe and dayofweek == dayofweek.wednesday
is_thursday_blocked = blockTh and dayofweek == dayofweek.thursday
is_friday_blocked = blockFr and dayofweek == dayofweek.friday
is_saturday_blocked = blockSa and dayofweek == dayofweek.saturday
is_sunday_blocked = blockSu and dayofweek == dayofweek.sunday

day_blocked = is_monday_blocked or is_tuesday_blocked or is_wednesday_blocked or is_thursday_blocked or is_friday_blocked or is_saturday_blocked or is_sunday_blocked
day_filter = not day_blocked

// Initialize signal variables - EXPANDED RSI LOGIC WITH SIGNAL MEMORY
// RSI1 Signals - ENHANCED with multiple signal types and memory
rsi1_long_signal = true
if useRSI1
    // Calculate current signals based on type
    current_rsi1_long_signal = false
    rsi1_rising = rsi1_value > rsi1_value[rsi1_direction_period]
    rsi1_falling = rsi1_value < rsi1_value[rsi1_direction_period]
    
    if rsi1_condition == "Oversold"
        current_rsi1_long_signal := rsi1_value <= rsi1_oversold
    else if rsi1_condition == "Above 50"
        current_rsi1_long_signal := rsi1_value > 50
    else if rsi1_condition == "Custom Range"
        current_rsi1_long_signal := rsi1_value >= rsi1_custom_min and rsi1_value <= rsi1_custom_max
    else if rsi1_condition == "Cross Level Up"
        current_rsi1_long_signal := rsi1_cross_up
    else if rsi1_condition == "Cross Level Down"
        current_rsi1_long_signal := rsi1_cross_down
    else if rsi1_condition == "Rising/Falling"
        current_rsi1_long_signal := rsi1_rising
    else
        current_rsi1_long_signal := false
    
    // Signal Memory Logic
    if current_rsi1_long_signal
        rsi1_signal_bar := bar_index
    
    memory_active = rsi1_signal_memory and bar_index - rsi1_signal_bar <= rsi1_memory_bars
    rsi1_long_signal := current_rsi1_long_signal or memory_active

// RSI1 Short Signals
rsi1_short_signal = true
if useRSI1
    current_rsi1_short_signal = false
    
    if rsi1_condition == "Oversold"
        current_rsi1_short_signal := rsi1_value >= rsi1_overbought
    else if rsi1_condition == "Above 50"
        current_rsi1_short_signal := rsi1_value < 50
    else if rsi1_condition == "Custom Range"
        current_rsi1_short_signal := rsi1_value <= rsi1_custom_min or rsi1_value >= rsi1_custom_max
    else if rsi1_condition == "Cross Level Up"
        current_rsi1_short_signal := rsi1_cross_down
    else if rsi1_condition == "Cross Level Down"
        current_rsi1_short_signal := rsi1_cross_up
    else if rsi1_condition == "Rising/Falling"
        current_rsi1_short_signal := rsi1_value < rsi1_value[rsi1_direction_period]
    else
        current_rsi1_short_signal := false
    
    memory_active_short = rsi1_signal_memory and bar_index - rsi1_signal_bar <= rsi1_memory_bars
    rsi1_short_signal := current_rsi1_short_signal or memory_active_short

// RSI2 Signals - ENHANCED with multiple signal types and memory
rsi2_long_signal = true
if useRSI2
    current_rsi2_long_signal = false
    rsi2_rising = rsi2_value > rsi2_value[rsi2_direction_period]
    
    if rsi2_condition == "Oversold"
        current_rsi2_long_signal := rsi2_value <= rsi2_oversold
    else if rsi2_condition == "Above 50"
        current_rsi2_long_signal := rsi2_value > 50
    else if rsi2_condition == "Custom Range"
        current_rsi2_long_signal := rsi2_value >= rsi2_custom_min and rsi2_value <= rsi2_custom_max
    else if rsi2_condition == "Cross Level Up"
        current_rsi2_long_signal := rsi2_cross_up
    else if rsi2_condition == "Cross Level Down"
        current_rsi2_long_signal := rsi2_cross_down
    else if rsi2_condition == "Rising/Falling"
        current_rsi2_long_signal := rsi2_rising
    else
        current_rsi2_long_signal := false
    
    if current_rsi2_long_signal
        rsi2_signal_bar := bar_index
    
    memory_active_2 = rsi2_signal_memory and bar_index - rsi2_signal_bar <= rsi2_memory_bars
    rsi2_long_signal := current_rsi2_long_signal or memory_active_2

rsi2_short_signal = true
if useRSI2
    current_rsi2_short_signal = false
    
    if rsi2_condition == "Oversold"
        current_rsi2_short_signal := rsi2_value >= rsi2_overbought
    else if rsi2_condition == "Above 50"
        current_rsi2_short_signal := rsi2_value < 50
    else if rsi2_condition == "Custom Range"
        current_rsi2_short_signal := rsi2_value <= rsi2_custom_min or rsi2_value >= rsi2_custom_max
    else if rsi2_condition == "Cross Level Up"
        current_rsi2_short_signal := rsi2_cross_down
    else if rsi2_condition == "Cross Level Down"
        current_rsi2_short_signal := rsi2_cross_up
    else if rsi2_condition == "Rising/Falling"
        current_rsi2_short_signal := rsi2_value < rsi2_value[rsi2_direction_period]
    else
        current_rsi2_short_signal := false
    
    memory_active_2_short = rsi2_signal_memory and bar_index - rsi2_signal_bar <= rsi2_memory_bars
    rsi2_short_signal := current_rsi2_short_signal or memory_active_2_short

// RSI3 Signals - ENHANCED with multiple signal types and memory
rsi3_long_signal = true
if useRSI3
    current_rsi3_long_signal = false
    rsi3_rising = rsi3_value > rsi3_value[rsi3_direction_period]
    
    if rsi3_condition == "Oversold"
        current_rsi3_long_signal := rsi3_value <= rsi3_oversold
    else if rsi3_condition == "Above 50"
        current_rsi3_long_signal := rsi3_value > 50
    else if rsi3_condition == "Custom Range"
        current_rsi3_long_signal := rsi3_value >= rsi3_custom_min and rsi3_value <= rsi3_custom_max
    else if rsi3_condition == "Cross Level Up"
        current_rsi3_long_signal := rsi3_cross_up
    else if rsi3_condition == "Cross Level Down"
        current_rsi3_long_signal := rsi3_cross_down
    else if rsi3_condition == "Rising/Falling"
        current_rsi3_long_signal := rsi3_rising
    else
        current_rsi3_long_signal := false
    
    if current_rsi3_long_signal
        rsi3_signal_bar := bar_index
    
    memory_active_3 = rsi3_signal_memory and bar_index - rsi3_signal_bar <= rsi3_memory_bars
    rsi3_long_signal := current_rsi3_long_signal or memory_active_3

rsi3_short_signal = true
if useRSI3
    current_rsi3_short_signal = false
    
    if rsi3_condition == "Oversold"
        current_rsi3_short_signal := rsi3_value >= rsi3_overbought
    else if rsi3_condition == "Above 50"
        current_rsi3_short_signal := rsi3_value < 50
    else if rsi3_condition == "Custom Range"
        current_rsi3_short_signal := rsi3_value <= rsi3_custom_min or rsi3_value >= rsi3_custom_max
    else if rsi3_condition == "Cross Level Up"
        current_rsi3_short_signal := rsi3_cross_down
    else if rsi3_condition == "Cross Level Down"
        current_rsi3_short_signal := rsi3_cross_up
    else if rsi3_condition == "Rising/Falling"
        current_rsi3_short_signal := rsi3_value < rsi3_value[rsi3_direction_period]
    else
        current_rsi3_short_signal := false
    
    memory_active_3_short = rsi3_signal_memory and bar_index - rsi3_signal_bar <= rsi3_memory_bars
    rsi3_short_signal := current_rsi3_short_signal or memory_active_3_short

// ENHANCED SuperTrend Signals with signal type selection and memory
// ST1 - ENHANCED with Signal Memory
st1_trend_up_calc = st1_direction == 1
st1_trend_down_calc = st1_direction == -1
st1_trend_change_up_calc = st1_trend_up_calc and st1_direction[1] == -1
st1_trend_change_down_calc = st1_trend_down_calc and st1_direction[1] == 1

current_st1_long_signal = false
if st1_signal_type == "Trend Change"
    current_st1_long_signal := st1_trend_change_up_calc
else if st1_signal_type == "Trend Filter"
    current_st1_long_signal := st1_trend_up_calc

current_st1_short_signal = false
if st1_signal_type == "Trend Change"
    current_st1_short_signal := st1_trend_change_down_calc
else if st1_signal_type == "Trend Filter"
    current_st1_short_signal := st1_trend_down_calc

// Signal Memory for ST1 - FIXED logic
if current_st1_long_signal or current_st1_short_signal
    st1_signal_bar := bar_index

st1_memory_active = st1_signal_memory and bar_index - st1_signal_bar <= st1_memory_bars
st1_long_signal = useST1 ? (current_st1_long_signal or (st1_memory_active and st1_trend_up_calc)) : true
st1_short_signal = useST1 ? (current_st1_short_signal or (st1_memory_active and st1_trend_down_calc)) : true

// ST2 - ENHANCED with Signal Memory  
st2_trend_up_calc = st2_direction == 1
st2_trend_down_calc = st2_direction == -1
st2_trend_change_up_calc = st2_trend_up_calc and st2_direction[1] == -1
st2_trend_change_down_calc = st2_trend_down_calc and st2_direction[1] == 1

current_st2_long_signal = false
if st2_signal_type == "Trend Change"
    current_st2_long_signal := st2_trend_change_up_calc
else if st2_signal_type == "Trend Filter"
    current_st2_long_signal := st2_trend_up_calc

current_st2_short_signal = false
if st2_signal_type == "Trend Change"
    current_st2_short_signal := st2_trend_change_down_calc
else if st2_signal_type == "Trend Filter"
    current_st2_short_signal := st2_trend_down_calc

if current_st2_long_signal or current_st2_short_signal
    st2_signal_bar := bar_index

st2_memory_active = st2_signal_memory and bar_index - st2_signal_bar <= st2_memory_bars
st2_long_signal = useST2 ? (current_st2_long_signal or (st2_memory_active and st2_trend_up_calc)) : true
st2_short_signal = useST2 ? (current_st2_short_signal or (st2_memory_active and st2_trend_down_calc)) : true

// ST3 - ENHANCED with Signal Memory
st3_trend_up_calc = st3_direction == 1
st3_trend_down_calc = st3_direction == -1
st3_trend_change_up_calc = st3_trend_up_calc and st3_direction[1] == -1
st3_trend_change_down_calc = st3_trend_down_calc and st3_direction[1] == 1

current_st3_long_signal = false
if st3_signal_type == "Trend Change"
    current_st3_long_signal := st3_trend_change_up_calc
else if st3_signal_type == "Trend Filter"
    current_st3_long_signal := st3_trend_up_calc

current_st3_short_signal = false
if st3_signal_type == "Trend Change"
    current_st3_short_signal := st3_trend_change_down_calc
else if st3_signal_type == "Trend Filter"
    current_st3_short_signal := st3_trend_down_calc

if current_st3_long_signal or current_st3_short_signal
    st3_signal_bar := bar_index

st3_memory_active = st3_signal_memory and bar_index - st3_signal_bar <= st3_memory_bars
st3_long_signal = useST3 ? (current_st3_long_signal or (st3_memory_active and st3_trend_up_calc)) : true
st3_short_signal = useST3 ? (current_st3_short_signal or (st3_memory_active and st3_trend_down_calc)) : true

// Volume filter - FIXED: replaced switch with if/else
volume_condition_result = true
if useVolumeFilter
    if volume_condition == "Above Average"
        volume_condition_result := volume > volume_avg * volume_multiplier
    else if volume_condition == "Below Average"
        volume_condition_result := volume < volume_avg / volume_multiplier
    else if volume_condition == "Rising"
        volume_condition_result := volume > volume[1]
    else if volume_condition == "Falling"
        volume_condition_result := volume < volume[1]
    else
        volume_condition_result := false

// Volatility filter - FIXED: replaced switch with if/else
volatility_condition_result = true
if useVolatilityFilter
    if vol_condition == "Rising"
        volatility_condition_result := volatility > volatility[1]
    else if vol_condition == "Falling"
        volatility_condition_result := volatility < volatility[1]
    else if vol_condition == "Above Level"
        volatility_condition_result := volatility > vol_threshold
    else if vol_condition == "Below Level"
        volatility_condition_result := volatility < vol_threshold
    else
        volatility_condition_result := false

// High/Low Filter
highlow_long_signal = true
if useHighLowFilter
    highest_price = ta.highest(high, highlow_period)
    lowest_price = ta.lowest(low, highlow_period)
    price_change = (close - lowest_price) / lowest_price * 100
    highlow_long_signal := price_change >= highlow_min_change

highlow_short_signal = true
if useHighLowFilter
    highest_price = ta.highest(high, highlow_period)
    lowest_price = ta.lowest(low, highlow_period)
    price_change = (highest_price - close) / highest_price * 100
    highlow_short_signal := price_change >= highlow_min_change

// ATR Change Filter
atr_change_signal = true
if useATRChangeFilter
    current_atr = ta.atr(14)
    past_atr = ta.sma(ta.atr(14), atr_change_period)
    atr_change = (current_atr - past_atr) / past_atr * 100
    atr_change_signal := atr_change >= atr_change_threshold

// Block If Worse Filter - IMPROVED: проверка за период, а не только текущая свеча
block_worse_long_signal = true
if useBlockIfWorse
    // Проверяем движение цены за последние 3 бара
    price_move_1 = (close - close[1]) / close[1] * 100
    price_move_2 = (close[1] - close[2]) / close[2] * 100
    price_move_3 = (close[2] - close[3]) / close[3] * 100
    max_positive_move = math.max(price_move_1, math.max(price_move_2, price_move_3))
    // Блокируем, если цена уже ушла в нашу сторону больше чем на X%
    block_worse_long_signal := not (max_positive_move > blockIfWorsePercent)

block_worse_short_signal = true
if useBlockIfWorse
    // Проверяем движение цены за последние 3 бара
    price_move_1 = (close - close[1]) / close[1] * 100
    price_move_2 = (close[1] - close[2]) / close[2] * 100
    price_move_3 = (close[2] - close[3]) / close[3] * 100
    max_negative_move = math.min(price_move_1, math.min(price_move_2, price_move_3))
    // Блокируем, если цена уже ушла в нашу сторону больше чем на X%
    block_worse_short_signal := not (max_negative_move < -blockIfWorsePercent)

// PinBar + MA
pinbar_ma_long_signal = true
if usePinBarMA
    ma1 = ta.ema(close, pinbar_ma1_length)
    ma2 = ta.ema(close, pinbar_ma2_length)
    ma3 = ta.ema(close, pinbar_ma3_length)
    is_pin = f_isHammer()
    ma_aligned = ma1 > ma2 and ma2 > ma3
    pinbar_ma_long_signal := is_pin and ma_aligned

pinbar_ma_short_signal = true
if usePinBarMA
    ma1 = ta.ema(close, pinbar_ma1_length)
    ma2 = ta.ema(close, pinbar_ma2_length)
    ma3 = ta.ema(close, pinbar_ma3_length)
    is_pin = f_isHammer()
    ma_aligned = ma1 < ma2 and ma2 < ma3
    pinbar_ma_short_signal := is_pin and ma_aligned

// Supertrend Filter (legacy) - FIXED: with signal type selection
supertrend_trend_up_calc = st_direction == 1
supertrend_trend_down_calc = st_direction == -1
supertrend_trend_change_up_calc = supertrend_trend_up_calc and st_direction[1] == -1
supertrend_trend_change_down_calc = supertrend_trend_down_calc and st_direction[1] == 1

supertrend_long_signal_calc = false
if st_signal_type == "Trend Change"
    supertrend_long_signal_calc := supertrend_trend_change_up_calc
else if st_signal_type == "Trend Filter"
    supertrend_long_signal_calc := supertrend_trend_up_calc

supertrend_short_signal_calc = false
if st_signal_type == "Trend Change"
    supertrend_short_signal_calc := supertrend_trend_change_down_calc
else if st_signal_type == "Trend Filter"
    supertrend_short_signal_calc := supertrend_trend_down_calc

supertrend_long_signal = useSupertrend ? supertrend_long_signal_calc : true
supertrend_short_signal = useSupertrend ? supertrend_short_signal_calc : true

// Consolidation Zone - FIXED: правильная логика консолидации
consolidation_signal = true
if useConsolidation
    highest_cons = ta.highest(high, consolidation_length)
    lowest_cons = ta.lowest(low, consolidation_length)
    range_percent = (highest_cons - lowest_cons) / lowest_cons * 100
    // ИСПРАВЛЕНО: для консолидации диапазон должен быть МЕНЬШЕ порога
    consolidation_signal := range_percent <= consolidation_range

// Moving Average Signals with Signal Memory - FIXED: simplified logic
ma_long_signal = true
ma_short_signal = true
if useMA
    ma_cross_long = ma_cross_over
    ma_cross_short = ma_cross_under
    ma_dir_long = ma_fast_val > ma_fast_val[1] and ma_slow_val > ma_slow_val[1]
    ma_dir_short = ma_fast_val < ma_fast_val[1] and ma_slow_val < ma_slow_val[1]
    ma_same_dir_long = ma_fast_val > ma_slow_val and ma_dir_long
    ma_same_dir_short = ma_fast_val < ma_slow_val and ma_dir_short
    
    current_ma_long_signal = false
    current_ma_short_signal = false
    
    if ma_signal_type == "Cross"
        current_ma_long_signal := ma_cross_long
        current_ma_short_signal := ma_cross_short
    else if ma_signal_type == "Direction"
        current_ma_long_signal := ma_dir_long
        current_ma_short_signal := ma_dir_short
    else if ma_signal_type == "Both Direction Same"
        current_ma_long_signal := ma_same_dir_long
        current_ma_short_signal := ma_same_dir_short
    
    if current_ma_long_signal or current_ma_short_signal
        ma_cross_bar := bar_index
    
    if ma_signal_memory and bar_index - ma_cross_bar <= ma_memory_bars
        memory_condition = bar_index - ma_cross_bar <= ma_memory_bars
        ma_long_signal := current_ma_long_signal or (memory_condition and current_ma_long_signal[bar_index - ma_cross_bar])
        ma_short_signal := current_ma_short_signal or (memory_condition and current_ma_short_signal[bar_index - ma_cross_bar])
    else
        ma_long_signal := current_ma_long_signal
        ma_short_signal := current_ma_short_signal

// Channels Conditions - FIXED: replaced switch with if/else
channels_long_signal = true
if useChannels
    touch_long = low <= channel_lower and close > channel_lower
    close_outside_long = close[1] < channel_lower and close > channel_lower
    breakout_long = close > channel_upper
    
    if channel_signal_type == "Touch"
        channels_long_signal := touch_long
    else if channel_signal_type == "Close Outside"
        channels_long_signal := close_outside_long
    else if channel_signal_type == "Breakout"
        channels_long_signal := breakout_long
    else
        channels_long_signal := false

channels_short_signal = true
if useChannels
    touch_short = high >= channel_upper and close < channel_upper
    close_outside_short = close[1] > channel_upper and close < channel_upper
    breakout_short = close < channel_lower
    
    if channel_signal_type == "Touch"
        channels_short_signal := touch_short
    else if channel_signal_type == "Close Outside"
        channels_short_signal := close_outside_short
    else if channel_signal_type == "Breakout"
        channels_short_signal := breakout_short
    else
        channels_short_signal := false

// Other indicator signals (keeping existing logic but with proper boolean returns)
rvi_long_signal = useRVI ? rvi_val < rvi_oversold : true
rvi_short_signal = useRVI ? rvi_val > rvi_overbought : true

mfi_long_signal = useMFI ? mfi_val < mfi_oversold : true
mfi_short_signal = useMFI ? mfi_val > mfi_overbought : true

// Stochastic Signals - ENHANCED with multiple signal types and memory
stoch_long_signal = true
stoch_short_signal = true
if useStochastic
    // Calculate different signal types
    current_stoch_long_signal = false
    current_stoch_short_signal = false
    
    stoch_rising = stoch_k_smoothed > stoch_k_smoothed[stoch_direction_period]
    stoch_falling = stoch_k_smoothed < stoch_k_smoothed[stoch_direction_period]
    stoch_k_d_cross_up = ta.crossover(stoch_k_smoothed, stoch_d)
    stoch_k_d_cross_down = ta.crossunder(stoch_k_smoothed, stoch_d)
    
    if stoch_signal_type == "Oversold Cross"
        current_stoch_long_signal := stoch_cross_up
        current_stoch_short_signal := stoch_cross_down
    else if stoch_signal_type == "Overbought Cross"
        current_stoch_long_signal := ta.crossunder(stoch_k_smoothed, stoch_overbought)
        current_stoch_short_signal := ta.crossover(stoch_k_smoothed, stoch_oversold)
    else if stoch_signal_type == "K-D Cross"
        current_stoch_long_signal := stoch_k_d_cross_up
        current_stoch_short_signal := stoch_k_d_cross_down
    else if stoch_signal_type == "Level Filter"
        current_stoch_long_signal := stoch_k_smoothed < stoch_oversold
        current_stoch_short_signal := stoch_k_smoothed > stoch_overbought
    else if stoch_signal_type == "Rising/Falling"
        current_stoch_long_signal := stoch_rising
        current_stoch_short_signal := stoch_falling
    
    // Signal Memory Logic
    if current_stoch_long_signal or current_stoch_short_signal
        stoch_signal_bar := bar_index
    
    stoch_memory_active = stoch_signal_memory and bar_index - stoch_signal_bar <= stoch_memory_bars
    stoch_long_signal := current_stoch_long_signal or (stoch_memory_active and current_stoch_long_signal)
    stoch_short_signal := current_stoch_short_signal or (stoch_memory_active and current_stoch_short_signal)

cci_long_signal = useCCI ? cci_val < cci_oversold : true
cci_short_signal = useCCI ? cci_val > cci_overbought : true

momentum_long_signal = useMomentum ? momentum_val < momentum_oversold : true
momentum_short_signal = useMomentum ? momentum_val > momentum_overbought : true

drsi_long_signal = useDynamicRSI ? rsi1_value < drsi_lower : true
drsi_short_signal = useDynamicRSI ? rsi1_value > drsi_upper : true

dmfi_long_signal = useDynamicMFI ? mfi_val < dmfi_lower : true
dmfi_short_signal = useDynamicMFI ? mfi_val > dmfi_upper : true

smi_long_signal = useSMIO ? smi_val < smio_oversold : true
smi_short_signal = useSMIO ? smi_val > smio_overbought : true

// DMI Condition - ENHANCED with Signal Memory and ADX Rising
dmi_long_signal = true
dmi_short_signal = true
if useDMI
    current_dmi_long_signal = false
    current_dmi_short_signal = false
    
    adx_strong = adx > dmi_adx_threshold
    adx_rising_calc = adx > adx[dmi_adx_period]
    
    if dmi_signal_type == "DI Cross"
        current_dmi_long_signal := di_cross_long
        current_dmi_short_signal := di_cross_short
    else if dmi_signal_type == "ADX Level"
        current_dmi_long_signal := adx_strong and diplus > diminus
        current_dmi_short_signal := adx_strong and diminus > diplus
    else if dmi_signal_type == "Both"
        current_dmi_long_signal := di_cross_long and adx_strong
        current_dmi_short_signal := di_cross_short and adx_strong
    else if dmi_signal_type == "ADX Rising"
        current_dmi_long_signal := adx_rising_calc and diplus > diminus
        current_dmi_short_signal := adx_rising_calc and diminus > diplus
    
    // Apply ADX Rising filter if enabled
    if dmi_adx_rising
        current_dmi_long_signal := current_dmi_long_signal and adx_rising_calc
        current_dmi_short_signal := current_dmi_short_signal and adx_rising_calc
    
    // Signal Memory Logic
    if current_dmi_long_signal or current_dmi_short_signal
        dmi_signal_bar := bar_index
    
    dmi_memory_active = dmi_signal_memory and bar_index - dmi_signal_bar <= dmi_memory_bars
    dmi_long_signal := current_dmi_long_signal or (dmi_memory_active and diplus > diminus)
    dmi_short_signal := current_dmi_short_signal or (dmi_memory_active and diminus > diplus)

// Chaikin Money Flow
chaikin_long_signal = true
if useChaikin
    cmf_ob_os = cmf_val < chaikin_oversold
    cmf_zero = chaikin_use_zero and cmf_cross_up
    chaikin_long_signal := cmf_ob_os or cmf_zero

chaikin_short_signal = true
if useChaikin
    cmf_ob_os = cmf_val > chaikin_overbought
    cmf_zero = chaikin_use_zero and cmf_cross_down
    chaikin_short_signal := cmf_ob_os or cmf_zero

// Balance of Power
bop_long_signal = true
if useBOP
    bop_ob_os = bop_val < bop_oversold
    bop_zero = bop_use_zero and bop_cross_up
    bop_long_signal := bop_ob_os or bop_zero

bop_short_signal = true
if useBOP
    bop_ob_os = bop_val > bop_overbought
    bop_zero = bop_use_zero and bop_cross_down
    bop_short_signal := bop_ob_os or bop_zero

// MACD Condition with Signal Memory - FIXED: replaced switch with if/else
macd_long_signal = true
macd_short_signal = true
if useMACD
    signal_cross_long = macd_signal_cross_up
    signal_cross_short = macd_signal_cross_down
    zero_cross_long = macd_zero_cross_up
    zero_cross_short = macd_zero_cross_down
    
    current_macd_long_signal = false
    current_macd_short_signal = false
    
    if macd_signal_type == "Signal Cross"
        current_macd_long_signal := signal_cross_long
        current_macd_short_signal := signal_cross_short
    else if macd_signal_type == "Zero Cross"
        current_macd_long_signal := zero_cross_long
        current_macd_short_signal := zero_cross_short
    else if macd_signal_type == "Both"
        current_macd_long_signal := signal_cross_long or zero_cross_long
        current_macd_short_signal := signal_cross_short or zero_cross_short
    
    if current_macd_long_signal or current_macd_short_signal
        macd_cross_bar := bar_index
    
    if macd_signal_memory and bar_index - macd_cross_bar <= macd_memory_bars
        macd_long_signal := current_macd_long_signal
        macd_short_signal := current_macd_short_signal
    else
        macd_long_signal := current_macd_long_signal
        macd_short_signal := current_macd_short_signal

// QQE Signals
qqe_long_signal = useQQE ? (qqe_trend == 1 and qqe_trend[1] != 1) : true
qqe_short_signal = useQQE ? (qqe_trend == -1 and qqe_trend[1] != -1) : true

// PROFESSIONAL LEVELS IMPLEMENTATION - Support/Resistance Detection
levels_long_signal = true
levels_short_signal = true

if useLevels
    // Enhanced settings for level detection
    pivot_left = 5
    pivot_right = 5
    level_tolerance_percent = input.float(0.3, "Level Tolerance %", minval=0.1, maxval=1.0, step=0.1, group=levels_group)
    
    // Find pivot highs and lows
    pivot_high = ta.pivothigh(high, pivot_left, pivot_right)
    pivot_low = ta.pivotlow(low, pivot_left, pivot_right)
    
    // Arrays to store levels and their touch counts
    var array<float> resistance_levels = array.new<float>()
    var array<int> resistance_touches = array.new<int>()
    var array<float> support_levels = array.new<float>()
    var array<int> support_touches = array.new<int>()
    
    // Add new pivot high as potential resistance
    if not na(pivot_high)
        level_found = false
        level_index = -1
        
        // Check if this level already exists (within tolerance)
        if array.size(resistance_levels) > 0
            for i = 0 to array.size(resistance_levels) - 1
                existing_level = array.get(resistance_levels, i)
                if math.abs(pivot_high - existing_level) / existing_level * 100 <= level_tolerance_percent
                    level_found := true
                    level_index := i
                    break
        
        if level_found and level_index >= 0
            // Increment touch count for existing level
            current_touches = array.get(resistance_touches, level_index)
            array.set(resistance_touches, level_index, current_touches + 1)
            // Update level to average price
            existing_level = array.get(resistance_levels, level_index)
            new_level = (existing_level * current_touches + pivot_high) / (current_touches + 1)
            array.set(resistance_levels, level_index, new_level)
        else
            // Add new resistance level
            array.push(resistance_levels, pivot_high)
            array.push(resistance_touches, 1)
    
    // Add new pivot low as potential support
    if not na(pivot_low)
        level_found = false
        level_index = -1
        
        // Check if this level already exists (within tolerance)
        if array.size(support_levels) > 0
            for i = 0 to array.size(support_levels) - 1
                existing_level = array.get(support_levels, i)
                if math.abs(pivot_low - existing_level) / existing_level * 100 <= level_tolerance_percent
                    level_found := true
                    level_index := i
                    break
        
        if level_found and level_index >= 0
            // Increment touch count for existing level
            current_touches = array.get(support_touches, level_index)
            array.set(support_touches, level_index, current_touches + 1)
            // Update level to average price
            existing_level = array.get(support_levels, level_index)
            new_level = (existing_level * current_touches + pivot_low) / (current_touches + 1)
            array.set(support_levels, level_index, new_level)
        else
            // Add new support level
            array.push(support_levels, pivot_low)
            array.push(support_touches, 1)
    
    // Clean old levels (keep only recent X levels)
    max_levels = 20
    if array.size(resistance_levels) > max_levels
        array.shift(resistance_levels)
        array.shift(resistance_touches)
    if array.size(support_levels) > max_levels
        array.shift(support_levels)
        array.shift(support_touches)
    
    // Check proximity to significant levels for signals
    near_resistance = false
    near_support = false
    
    if array.size(resistance_levels) > 0
        for i = 0 to array.size(resistance_levels) - 1
            touches = array.get(resistance_touches, i)
            if touches >= level_min_touches
                level_price = array.get(resistance_levels, i)
                distance_percent = math.abs(close - level_price) / close * 100
                if distance_percent <= level_proximity
                    near_resistance := true
                    break
    
    if array.size(support_levels) > 0
        for i = 0 to array.size(support_levels) - 1
            touches = array.get(support_touches, i)
            if touches >= level_min_touches
                level_price = array.get(support_levels, i)
                distance_percent = math.abs(close - level_price) / close * 100
                if distance_percent <= level_proximity
                    near_support := true
                    break
    
    // Generate signals based on level interaction
    levels_long_signal := near_support  // Buy near support
    levels_short_signal := near_resistance  // Sell near resistance

// ENHANCED Divergence Detection for multiple indicators with Signal Memory
divergence_long_signal = true
divergence_short_signal = true

if useDivergence
    current_div_long_signal = false
    current_div_short_signal = false
    
    // RSI Divergence
    if div_rsi and useRSI1
        [rsi_bull_div, rsi_bear_div] = detect_divergence_professional(close, rsi1_value, div_pivot_lookback, div_min_pivot_distance)
        current_div_long_signal := current_div_long_signal or rsi_bull_div
        current_div_short_signal := current_div_short_signal or rsi_bear_div
    
    // MACD Divergence - NEWLY IMPLEMENTED
    if div_macd and useMACD
        [macd_bull_div, macd_bear_div] = detect_divergence_professional(close, macd_line, div_pivot_lookback, div_min_pivot_distance)
        current_div_long_signal := current_div_long_signal or macd_bull_div
        current_div_short_signal := current_div_short_signal or macd_bear_div
    
    // MFI Divergence - NEWLY IMPLEMENTED
    if div_mfi and useMFI
        [mfi_bull_div, mfi_bear_div] = detect_divergence_professional(close, mfi_val, div_pivot_lookback, div_min_pivot_distance)
        current_div_long_signal := current_div_long_signal or mfi_bull_div
        current_div_short_signal := current_div_short_signal or mfi_bear_div
    
    // CCI Divergence - NEWLY IMPLEMENTED
    if div_cci and useCCI
        [cci_bull_div, cci_bear_div] = detect_divergence_professional(close, cci_val, div_pivot_lookback, div_min_pivot_distance)
        current_div_long_signal := current_div_long_signal or cci_bull_div
        current_div_short_signal := current_div_short_signal or cci_bear_div
    
    // Momentum Divergence - NEWLY IMPLEMENTED
    if div_momentum and useMomentum
        [momentum_bull_div, momentum_bear_div] = detect_divergence_professional(close, momentum_val, div_pivot_lookback, div_min_pivot_distance)
        current_div_long_signal := current_div_long_signal or momentum_bull_div
        current_div_short_signal := current_div_short_signal or momentum_bear_div
    
    // OBV Divergence - NEWLY IMPLEMENTED (simple OBV calculation)
    if div_obv
        obv_val = ta.cum(math.sign(ta.change(close)) * volume)
        [obv_bull_div, obv_bear_div] = detect_divergence_professional(close, obv_val, div_pivot_lookback, div_min_pivot_distance)
        current_div_long_signal := current_div_long_signal or obv_bull_div
        current_div_short_signal := current_div_short_signal or obv_bear_div
    
    // Signal Memory for Divergences
    if current_div_long_signal or current_div_short_signal
        divergence_signal_bar := bar_index
    
    div_memory_active = div_signal_memory and bar_index - divergence_signal_bar <= div_memory_bars
    divergence_long_signal := current_div_long_signal or (div_memory_active and current_div_long_signal)
    divergence_short_signal := current_div_short_signal or (div_memory_active and current_div_short_signal)

// Candle Patterns
candle_long_signal = true
if useCandlePatterns
    bull_hammer = use_hammer and f_isHammer() and close > open
    bull_engulfing = use_engulfing and f_isEngulfingBull()
    bull_doji = use_doji and f_isDoji() and close > ta.sma(close, 20)
    bull_morning_star = use_morning_evening_star and f_isMorningStar()
    bull_soldiers = use_three_soldiers_crows and f_isThreeWhiteSoldiers()
    
    candle_long_signal := bull_hammer or bull_engulfing or bull_doji or bull_morning_star or bull_soldiers

candle_short_signal = true
if useCandlePatterns
    bear_hammer = use_hammer and f_isHammer() and close < open
    bear_engulfing = use_engulfing and f_isEngulfingBear()
    bear_doji = use_doji and f_isDoji() and close < ta.sma(close, 20)
    bear_evening_star = use_morning_evening_star and f_isEveningStar()
    bear_crows = use_three_soldiers_crows and f_isThreeBlackCrows()
    
    candle_short_signal := bear_hammer or bear_engulfing or bear_doji or bear_evening_star or bear_crows

// Linear Regression Channel
lrc_long_signal = useLRC ? close < lrc_lower : true
lrc_short_signal = useLRC ? close > lrc_upper : true

// External Indicator - FIXED: replaced switch with if/else
external_long_signal = true
if useExternal
    if external_condition == "Above"
        external_long_signal := external_source > external_level
    else if external_condition == "Below"
        external_long_signal := external_source < external_level
    else if external_condition == "Cross Up"
        external_long_signal := external_cross_up
    else if external_condition == "Cross Down"
        external_long_signal := external_cross_down
    else
        external_long_signal := false

external_short_signal = true
if useExternal
    if external_condition == "Above"
        external_short_signal := external_source < external_level
    else if external_condition == "Below"
        external_short_signal := external_source > external_level
    else if external_condition == "Cross Up"
        external_short_signal := external_cross_down
    else if external_condition == "Cross Down"
        external_short_signal := external_cross_up
    else
        external_short_signal := false

// ===============================
// FINAL SIGNAL CONDITIONS - FIXED: COMPLETE INDICATORS COUNT
// ===============================
// Count ALL active indicators for proper filtering
rsi_count = (useRSI1 ? 1 : 0) + (useRSI2 ? 1 : 0) + (useRSI3 ? 1 : 0)
st_count = (useST1 ? 1 : 0) + (useST2 ? 1 : 0) + (useST3 ? 1 : 0) + (useSupertrend ? 1 : 0)
filter_count = (useVolumeFilter ? 1 : 0) + (useVolatilityFilter ? 1 : 0) + (useHighLowFilter ? 1 : 0) + (useATRChangeFilter ? 1 : 0) + (useBlockIfWorse ? 1 : 0)
basic_count = (usePinBarMA ? 1 : 0) + (useConsolidation ? 1 : 0) + (useMA ? 1 : 0) + (useChannels ? 1 : 0)
osc_count = (useRVI ? 1 : 0) + (useMFI ? 1 : 0) + (useStochastic ? 1 : 0) + (useCCI ? 1 : 0) + (useMomentum ? 1 : 0)
dyn_count = (useDynamicRSI ? 1 : 0) + (useDynamicMFI ? 1 : 0) + (useSMIO ? 1 : 0) + (useDMI ? 1 : 0) + (useChaikin ? 1 : 0)
adv_count = (useBOP ? 1 : 0) + (useMACD ? 1 : 0) + (useLevels ? 1 : 0) + (useQQE ? 1 : 0) + (useDivergence ? 1 : 0)
pattern_count = (useCandlePatterns ? 1 : 0) + (useLRC ? 1 : 0) + (useExternal ? 1 : 0)

active_indicators_count = rsi_count + st_count + filter_count + basic_count + osc_count + dyn_count + adv_count + pattern_count

// Comprehensive signal combination - FIXED: ALL SIGNALS INCLUDED
// RSI signals group
rsi_signals_long = rsi1_long_signal and rsi2_long_signal and rsi3_long_signal
rsi_signals_short = rsi1_short_signal and rsi2_short_signal and rsi3_short_signal

// SuperTrend signals group  
st_signals_long = st1_long_signal and st2_long_signal and st3_long_signal and supertrend_long_signal
st_signals_short = st1_short_signal and st2_short_signal and st3_short_signal and supertrend_short_signal

// Filter signals group
filter_signals = volume_condition_result and volatility_condition_result and atr_change_signal and consolidation_signal
filter_signals_long = filter_signals and highlow_long_signal and block_worse_long_signal and pinbar_ma_long_signal
filter_signals_short = filter_signals and highlow_short_signal and block_worse_short_signal and pinbar_ma_short_signal

// Core indicators group
core_signals_long = ma_long_signal and channels_long_signal and rvi_long_signal and mfi_long_signal and stoch_long_signal
core_signals_short = ma_short_signal and channels_short_signal and rvi_short_signal and mfi_short_signal and stoch_short_signal

// Oscillators group
osc_signals_long = cci_long_signal and momentum_long_signal and drsi_long_signal and dmfi_long_signal and smi_long_signal
osc_signals_short = cci_short_signal and momentum_short_signal and drsi_short_signal and dmfi_short_signal and smi_short_signal

// Advanced indicators group
adv_signals_long = dmi_long_signal and chaikin_long_signal and bop_long_signal and macd_long_signal and levels_long_signal
adv_signals_short = dmi_short_signal and chaikin_short_signal and bop_short_signal and macd_short_signal and levels_short_signal

// Pattern and external signals group
pattern_signals_long = qqe_long_signal and divergence_long_signal and candle_long_signal and lrc_long_signal and external_long_signal
pattern_signals_short = qqe_short_signal and divergence_short_signal and candle_short_signal and lrc_short_signal and external_short_signal

// Final combined signals
all_long_signals = rsi_signals_long and st_signals_long and filter_signals_long and core_signals_long and osc_signals_long and adv_signals_long and pattern_signals_long
all_short_signals = rsi_signals_short and st_signals_short and filter_signals_short and core_signals_short and osc_signals_short and adv_signals_short and pattern_signals_short

// Basic conditions check
basic_conditions = date_filter and day_filter

// Direction setup
long_direction = enableDCA ? gridDirection == "Long" : useLong
short_direction = enableDCA ? gridDirection == "Short" : useShort

// Final signals - only when position is 0 and on bar close
final_long_condition = long_direction and all_long_signals and basic_conditions and strategy.position_size == 0 and barstate.isconfirmed
final_short_condition = short_direction and all_short_signals and basic_conditions and strategy.position_size == 0 and barstate.isconfirmed

// ===============================
// DCA GRID VARIABLES
// ===============================
var float entry_price = na
var int order_count = 0
var float grid_step = na
var array<float> dca_levels = array.new<float>()
var array<bool> dca_order_placed = array.new<bool>()
var float total_position_size = 0.0
var float weighted_avg_price = 0.0
var float trailing_stop_level = na
var bool breakeven_activated = false
var bool position_closed = false

// DCA Functions
reset_dca_tracking() =>
    array.clear(dca_order_placed)
    for i = 0 to numberOfOrders - 1
        array.push(dca_order_placed, false)

get_position_size(order_index) =>
    base_size = depositForBot / numberOfOrders
    martingale_size = base_size * math.pow(martingaleMultiplier, order_index - 1)
    martingale_size * leverage

// Initialize DCA Grid
if enableDCA and (final_long_condition or final_short_condition) and na(entry_price)
    entry_price := close
    order_count := 1
    grid_step := entry_price * gridSizePercent / 100
    
    array.clear(dca_levels)
    array.push(dca_levels, entry_price)
    
    reset_dca_tracking()
    array.set(dca_order_placed, 0, true)
    
    for i = 1 to numberOfOrders - 1
        step_multiplier = math.pow(logarithmicSteps, i - 1)
        level_distance = grid_step * step_multiplier * i
        level = gridDirection == "Long" ? entry_price - level_distance : entry_price + level_distance
        array.push(dca_levels, level)

// Check for big drawdown
check_big_drawdown = closeOnBigDrawdown and strategy.position_size != 0 and strategy.openprofit <= drawdownToClose

if check_big_drawdown
    strategy.close_all(comment="Big Drawdown")
    entry_price := na
    order_count := 0
    total_position_size := 0.0
    weighted_avg_price := 0.0
    trailing_stop_level := na
    breakeven_activated := false
    position_closed := true

// ===============================
// STRATEGY EXECUTION
// ===============================
// Order Indent Logic
var float indent_price = na
var int indent_bar_count = 0

if useOrderIndent and (final_long_condition or final_short_condition) and strategy.position_size == 0
    indent_direction = final_long_condition ? -1 : 1
    indent_price := close * (1 + indent_direction * indentPercent / 100)
    indent_bar_count := 0

if not na(indent_price)
    indent_bar_count += 1
    if indent_bar_count > indentCancelBars
        indent_price := na
        indent_bar_count := 0

// Execute Orders
if enableDCA
    // Entry with indent
    entry_condition_long = gridDirection == "Long" and strategy.position_size == 0 and (useOrderIndent ? not na(indent_price) and close <= indent_price : final_long_condition)
    
    entry_condition_short = gridDirection == "Short" and strategy.position_size == 0 and (useOrderIndent ? not na(indent_price) and close >= indent_price : final_short_condition)
    
    if entry_condition_long
        qty = get_position_size(1) / close
        strategy.entry("DCA_L1", strategy.long, qty=qty)
        total_position_size := qty
        weighted_avg_price := close
        indent_price := na
        indent_bar_count := 0
        position_closed := false
    
    if entry_condition_short
        qty = get_position_size(1) / close
        strategy.entry("DCA_S1", strategy.short, qty=qty)
        total_position_size := qty
        weighted_avg_price := close
        indent_price := na
        indent_bar_count := 0
        position_closed := false
    
    // DCA Orders
    if not na(entry_price) and order_count < numberOfOrders and not position_closed
        if gridDirection == "Long" and strategy.position_size > 0
            for i = order_count to numberOfOrders - 1
                if not array.get(dca_order_placed, i)
                    next_level = array.get(dca_levels, i)
                    if close <= next_level
                        order_count += 1
                        qty = get_position_size(order_count) / close
                        strategy.entry("DCA_L" + str.tostring(order_count), strategy.long, qty=qty)
                        array.set(dca_order_placed, i, true)
                        
                        total_position_size := total_position_size + qty
                        weighted_avg_price := (weighted_avg_price * (total_position_size - qty) + close * qty) / total_position_size
                        break
        
        if gridDirection == "Short" and strategy.position_size < 0
            for i = order_count to numberOfOrders - 1
                if not array.get(dca_order_placed, i)
                    next_level = array.get(dca_levels, i)
                    if close >= next_level
                        order_count += 1
                        qty = get_position_size(order_count) / close
                        strategy.entry("DCA_S" + str.tostring(order_count), strategy.short, qty=qty)
                        array.set(dca_order_placed, i, true)
                        
                        total_position_size := total_position_size + qty
                        weighted_avg_price := (weighted_avg_price * (total_position_size - qty) + close * qty) / total_position_size
                        break

else
    // Simple Long/Short without DCA
    if final_long_condition and strategy.position_size == 0
        if useOrderIndent
            indent_price := close * (1 - indentPercent / 100)
            indent_bar_count := 0
        else
            strategy.entry("Long", strategy.long)
            position_closed := false
    
    if final_short_condition and strategy.position_size == 0
        if useOrderIndent
            indent_price := close * (1 + indentPercent / 100)
            indent_bar_count := 0
        else
            strategy.entry("Short", strategy.short)
            position_closed := false
    
    // Execute indent orders
    if not enableDCA and not na(indent_price) and strategy.position_size == 0
        if final_long_condition and close <= indent_price
            strategy.entry("Long", strategy.long)
            indent_price := na
            indent_bar_count := 0
            position_closed := false
        
        if final_short_condition and close >= indent_price
            strategy.entry("Short", strategy.short)
            indent_price := na
            indent_bar_count := 0
            position_closed := false

// ===============================
// EXIT MANAGEMENT - FIXED
// ===============================
// Calculate TP/SL levels
tp_percent = changeTakeProfit and order_count >= ifOrdersMoreThan ? newTakeProfitPercent : takeProfitPercent
sl_percent = slEqualsTp ? tp_percent : stopLossPercent

avg_price = enableDCA and not na(weighted_avg_price) ? weighted_avg_price : strategy.position_avg_price

// Breakeven Logic
if useBreakeven and strategy.position_size != 0 and not breakeven_activated
    profit_percent = 0.0
    if strategy.position_size > 0
        profit_percent := (close - avg_price) / avg_price * 100
    else
        profit_percent := (avg_price - close) / avg_price * 100
    
    if profit_percent >= breakevenActivation
        breakeven_activated := true

// Trailing Stop Logic
if useTrailingStop and strategy.position_size != 0
    profit_percent = 0.0
    if strategy.position_size > 0
        profit_percent := (close - avg_price) / avg_price * 100
    else
        profit_percent := (avg_price - close) / avg_price * 100
    
    if profit_percent >= trailingActivation
        if strategy.position_size > 0
            new_trailing_level = close * (1 - trailingDistance / 100)
            trailing_stop_level := na(trailing_stop_level) ? new_trailing_level : math.max(trailing_stop_level, new_trailing_level)
        else
            new_trailing_level = close * (1 + trailingDistance / 100)
            trailing_stop_level := na(trailing_stop_level) ? new_trailing_level : math.min(trailing_stop_level, new_trailing_level)

// Combined TP/SL Logic - FIXED: unified approach
if strategy.position_size != 0
    base_tp_level = 0.0
    base_sl_level = 0.0
    
    if strategy.position_size > 0
        // Long position
        base_tp_level := useATRTakeProfit ? avg_price + atr_tp_val * atr_tp_multiplier : avg_price * (1 + tp_percent / 100)
        base_sl_level := useATRStopLoss ? avg_price - atr_sl_val * atr_sl_multiplier : avg_price * (1 - sl_percent / 100)
        
        // Apply breakeven
        if breakeven_activated
            base_sl_level := math.max(base_sl_level, avg_price * (1 + breakevenLevel / 100))
        
        // Apply trailing stop
        if useTrailingStop and not na(trailing_stop_level)
            base_sl_level := math.max(base_sl_level, trailing_stop_level)
        
        // FIXED Multi TP Logic - using strategy.order with absolute qty only
        if useMultiTP and close_static_tp_sl
            tp1_price = avg_price * (1 + tp1_percent / 100)
            tp2_price = avg_price * (1 + tp2_percent / 100)
            tp3_price = avg_price * (1 + tp3_percent / 100)
            tp4_price = avg_price * (1 + tp4_percent / 100)
            
            total_qty = math.abs(strategy.position_size)
            tp1_qty_calc = total_qty * tp1_qty / 100
            tp2_qty_calc = total_qty * tp2_qty / 100
            tp3_qty_calc = total_qty * tp3_qty / 100
            remaining_qty = total_qty - tp1_qty_calc - tp2_qty_calc - tp3_qty_calc
            
            strategy.order("TP1_L", strategy.short, qty=tp1_qty_calc, limit=tp1_price)
            strategy.order("TP2_L", strategy.short, qty=tp2_qty_calc, limit=tp2_price)
            strategy.order("TP3_L", strategy.short, qty=tp3_qty_calc, limit=tp3_price)
            strategy.order("TP4_L", strategy.short, qty=remaining_qty, limit=tp4_price)
            
            // Stop loss order
            strategy.order("SL_L", strategy.short, qty=total_qty, stop=base_sl_level)
        else if close_static_tp_sl
            strategy.exit("Exit L", limit=base_tp_level, stop=base_sl_level)
    
    else
        // Short position
        base_tp_level := useATRTakeProfit ? avg_price - atr_tp_val * atr_tp_multiplier : avg_price * (1 - tp_percent / 100)
        base_sl_level := useATRStopLoss ? avg_price + atr_sl_val * atr_sl_multiplier : avg_price * (1 + sl_percent / 100)
        
        // Apply breakeven
        if breakeven_activated
            base_sl_level := math.min(base_sl_level, avg_price * (1 - breakevenLevel / 100))
        
        // Apply trailing stop
        if useTrailingStop and not na(trailing_stop_level)
            base_sl_level := math.min(base_sl_level, trailing_stop_level)
        
        // FIXED Multi TP Logic - using strategy.order with absolute qty only
        if useMultiTP and close_static_tp_sl
            tp1_price = avg_price * (1 - tp1_percent / 100)
            tp2_price = avg_price * (1 - tp2_percent / 100)
            tp3_price = avg_price * (1 - tp3_percent / 100)
            tp4_price = avg_price * (1 - tp4_percent / 100)
            
            total_qty = math.abs(strategy.position_size)
            tp1_qty_calc = total_qty * tp1_qty / 100
            tp2_qty_calc = total_qty * tp2_qty / 100
            tp3_qty_calc = total_qty * tp3_qty / 100
            remaining_qty = total_qty - tp1_qty_calc - tp2_qty_calc - tp3_qty_calc
            
            strategy.order("TP1_S", strategy.long, qty=tp1_qty_calc, limit=tp1_price)
            strategy.order("TP2_S", strategy.long, qty=tp2_qty_calc, limit=tp2_price)
            strategy.order("TP3_S", strategy.long, qty=tp3_qty_calc, limit=tp3_price)
            strategy.order("TP4_S", strategy.long, qty=remaining_qty, limit=tp4_price)
            
            // Stop loss order
            strategy.order("SL_S", strategy.long, qty=total_qty, stop=base_sl_level)
        else if close_static_tp_sl
            strategy.exit("Exit S", limit=base_tp_level, stop=base_sl_level)

// ===============================
// CLOSE SIGNALS - EXPANDED
// ===============================
// Parabolic SAR Close
if close_parabolic_sar and strategy.position_size != 0
    sar_close = (strategy.position_size > 0 and close < sar_val) or (strategy.position_size < 0 and close > sar_val)
    if sar_close and (not close_only_profit or strategy.openprofit > 0)
        strategy.close_all(comment="SAR Close")
        position_closed := true

// LRC Close
if close_lrc and strategy.position_size != 0 and useLRC
    lrc_close = (strategy.position_size > 0 and close > lrc_upper) or (strategy.position_size < 0 and close < lrc_lower)
    if lrc_close and (not close_only_profit or strategy.openprofit > 0)
        strategy.close_all(comment="LRC Close")
        position_closed := true

// Channel Close
if close_bb_kc and strategy.position_size != 0 and useChannels
    channel_close = (strategy.position_size > 0 and close > channel_upper) or (strategy.position_size < 0 and close < channel_lower)
    if channel_close and (not close_only_profit or strategy.openprofit > 0)
        strategy.close_all(comment="Channel Close")
        position_closed := true

// QQE Close
if close_qqe and strategy.position_size != 0 and useQQE
    qqe_close = (strategy.position_size > 0 and qqe_trend == -1) or (strategy.position_size < 0 and qqe_trend == 1)
    if qqe_close and (not close_only_profit or strategy.openprofit > 0)
        strategy.close_all(comment="QQE Close")
        position_closed := true

// RSI Close
if close_rsi and strategy.position_size != 0 and (useRSI1 or useRSI2 or useRSI3)
    rsi_close_val = useRSI1 ? rsi1_value : useRSI2 ? rsi2_value : rsi3_value
    rsi_ob = useRSI1 ? rsi1_overbought : useRSI2 ? rsi2_overbought : rsi3_overbought
    rsi_os = useRSI1 ? rsi1_oversold : useRSI2 ? rsi2_oversold : rsi3_oversold
    
    rsi_close = (strategy.position_size > 0 and rsi_close_val > rsi_ob) or (strategy.position_size < 0 and rsi_close_val < rsi_os)
    if rsi_close and (not close_only_profit or strategy.openprofit > 0)
        strategy.close_all(comment="RSI Close")
        position_closed := true

// Stochastic Close
if close_stoch and strategy.position_size != 0 and useStochastic
    stoch_close = (strategy.position_size > 0 and stoch_k_smoothed > stoch_overbought) or (strategy.position_size < 0 and stoch_k_smoothed < stoch_oversold)
    if stoch_close and (not close_only_profit or strategy.openprofit > 0)
        strategy.close_all(comment="Stoch Close")
        position_closed := true

// MA Cross Close - FIXED: use pre-calculated cross variables
if close_ma_cross and strategy.position_size != 0 and useMA
    ma_close = (strategy.position_size > 0 and ma_cross_under) or (strategy.position_size < 0 and ma_cross_over)
    if ma_close and (not close_only_profit or strategy.openprofit > 0)
        strategy.close_all(comment="MA Close")
        position_closed := true

// Pyramiding Logic
if usePyramiding and strategy.position_size != 0 and not position_closed
    price_move = 0.0
    if strategy.position_size > 0
        price_move := (close - avg_price) / avg_price * 100
    else
        price_move := (avg_price - close) / avg_price * 100
    
    if price_move >= pyramidMinMove
        if strategy.position_size > 0 and all_long_signals and basic_conditions
            strategy.entry("Pyramid L", strategy.long)
        if strategy.position_size < 0 and all_short_signals and basic_conditions
            strategy.entry("Pyramid S", strategy.short)

// FIXED Reverse Orders on SL
if useReverseOrderOnSL and strategy.closedtrades > 0
    last_trade = strategy.closedtrades - 1
    last_profit = strategy.closedtrades.profit(last_trade)
    
    if last_profit < 0 and barstate.isconfirmed and strategy.position_size == 0
        last_size = strategy.closedtrades.size(last_trade)
        reverse_qty = math.abs(last_size) * reverse_qty_percent / 100
        
        if last_size > 0  // Previous was long, reverse to short
            strategy.entry("Rev S", strategy.short, qty=reverse_qty)
        else  // Previous was short, reverse to long
            strategy.entry("Rev L", strategy.long, qty=reverse_qty)
        
        // Reset state variables for new position
        entry_price := na
        order_count := 0
        total_position_size := 0.0
        weighted_avg_price := 0.0
        trailing_stop_level := na
        breakeven_activated := false
        position_closed := false

// FIXED Reverse Orders on BE
if useReverseOrderOnBE and strategy.closedtrades > 0 and breakeven_activated
    last_trade = strategy.closedtrades - 1
    last_profit = strategy.closedtrades.profit(last_trade)
    
    if last_profit >= 0 and last_profit <= avg_price * breakevenLevel / 100 and barstate.isconfirmed and strategy.position_size == 0
        last_size = strategy.closedtrades.size(last_trade)
        reverse_qty = math.abs(last_size) * reverse_qty_percent / 100
        
        if last_size > 0  // Previous was long, reverse to short
            strategy.entry("Rev BE S", strategy.short, qty=reverse_qty)
        else  // Previous was short, reverse to long
            strategy.entry("Rev BE L", strategy.long, qty=reverse_qty)
        
        // Reset state variables for new position
        entry_price := na
        order_count := 0
        total_position_size := 0.0
        weighted_avg_price := 0.0
        trailing_stop_level := na
        breakeven_activated := false
        position_closed := false

// Reset variables when position closes
if strategy.position_size == 0
    if not na(entry_price)
        entry_price := na
        order_count := 0
        total_position_size := 0.0
        weighted_avg_price := 0.0
        trailing_stop_level := na
        breakeven_activated := false
    position_closed := false

// ===============================
// VISUALIZATION
// ===============================
// DCA Grid Visualization
if enableDCA and not na(entry_price) and showTPSL and barstate.islast
    for i = 0 to array.size(dca_levels) - 1
        if i < numberOfOrders
            level = array.get(dca_levels, i)
            is_placed = i < order_count
            line.new(bar_index - 10, level, bar_index + 10, level, 
                     color=is_placed ? color.green : color.orange, 
                     style=is_placed ? line.style_solid : line.style_dashed, 
                     width=1)

// TP/SL Visualization
if showTPSL and strategy.position_size != 0 and barstate.islast
    current_tp_percent = changeTakeProfit and order_count >= ifOrdersMoreThan ? newTakeProfitPercent : takeProfitPercent
    current_sl_percent = slEqualsTp ? current_tp_percent : stopLossPercent
    
    if strategy.position_size > 0
        tp_viz = useATRTakeProfit ? avg_price + atr_tp_val * atr_tp_multiplier : avg_price * (1 + current_tp_percent / 100)
        sl_viz = useATRStopLoss ? avg_price - atr_sl_val * atr_sl_multiplier : avg_price * (1 - current_sl_percent / 100)
        
        if breakeven_activated
            sl_viz := math.max(sl_viz, avg_price * (1 + breakevenLevel / 100))
        
        if useTrailingStop and not na(trailing_stop_level)
            sl_viz := math.max(sl_viz, trailing_stop_level)
        
        line.new(bar_index, tp_viz, bar_index + 5, tp_viz, color=color.green, width=2)
        line.new(bar_index, sl_viz, bar_index + 5, sl_viz, color=color.red, width=2)
        
        // Multi TP visualization
        if useMultiTP
            tp1_viz = avg_price * (1 + tp1_percent / 100)
            tp2_viz = avg_price * (1 + tp2_percent / 100)
            tp3_viz = avg_price * (1 + tp3_percent / 100)
            tp4_viz = avg_price * (1 + tp4_percent / 100)
            
            line.new(bar_index, tp1_viz, bar_index + 3, tp1_viz, color=color.lime, width=1, style=line.style_dashed)
            line.new(bar_index, tp2_viz, bar_index + 3, tp2_viz, color=color.lime, width=1, style=line.style_dashed)
            line.new(bar_index, tp3_viz, bar_index + 3, tp3_viz, color=color.lime, width=1, style=line.style_dashed)
            line.new(bar_index, tp4_viz, bar_index + 3, tp4_viz, color=color.lime, width=1, style=line.style_dashed)
    
    if strategy.position_size < 0
        tp_viz = useATRTakeProfit ? avg_price - atr_tp_val * atr_tp_multiplier : avg_price * (1 - current_tp_percent / 100)
        sl_viz = useATRStopLoss ? avg_price + atr_sl_val * atr_sl_multiplier : avg_price * (1 + current_sl_percent / 100)
        
        if breakeven_activated
            sl_viz := math.min(sl_viz, avg_price * (1 - breakevenLevel / 100))
        
        if useTrailingStop and not na(trailing_stop_level)
            sl_viz := math.min(sl_viz, trailing_stop_level)
        
        line.new(bar_index, tp_viz, bar_index + 5, tp_viz, color=color.green, width=2)
        line.new(bar_index, sl_viz, bar_index + 5, sl_viz, color=color.red, width=2)

// Signal Visualization
if showSignals
    if final_long_condition
        label.new(bar_index, low - atr_val, "LONG", 
                  color=color.green, style=label.style_label_up, textcolor=color.white, size=size.normal)
    
    if final_short_condition
        label.new(bar_index, high + atr_val, "SHORT", 
                  color=color.red, style=label.style_label_down, textcolor=color.white, size=size.normal)

// Trailing Stop Activation Visualization
if visualizeTrailingActivation and strategy.position_size != 0 and barstate.islast
    activation_level = 0.0
    if strategy.position_size > 0
        activation_level := avg_price * (1 + trailingActivation / 100)
    else
        activation_level := avg_price * (1 - trailingActivation / 100)
    line.new(bar_index, activation_level, bar_index + 5, activation_level, color=color.purple, width=1, style=line.style_dotted)

// Plot indicators
plot(useMA ? ma_fast_val : na, "Fast MA", color=color.blue, linewidth=1)
plot(useMA ? ma_slow_val : na, "Slow MA", color=color.red, linewidth=1)

plot(useChannels ? channel_upper : na, "Channel Upper", color=color.purple)
plot(useChannels ? channel_basis : na, "Channel Basis", color=color.gray)
plot(useChannels ? channel_lower : na, "Channel Lower", color=color.purple)

plot(useSupertrend ? st_line : na, "Supertrend", color=st_direction == 1 ? color.green : color.red, linewidth=2)

// Plot SuperTrend instances
plot(useST1 ? st1_line : na, "ST1", color=st1_direction == 1 ? color.lime : color.maroon, linewidth=1)
plot(useST2 ? st2_line : na, "ST2", color=st2_direction == 1 ? color.aqua : color.orange, linewidth=1)
plot(useST3 ? st3_line : na, "ST3", color=st3_direction == 1 ? color.blue : color.red, linewidth=1)

plotshape(close_parabolic_sar ? sar_val : na, style=shape.circle, location=location.absolute, color=close > sar_val ? color.green : color.red, size=size.tiny)

// ===============================
// ALERTS - FIXED: use final conditions
// ===============================
// Entry alerts
if final_long_condition
    if enableDCA and sendAlertFirstOrder
        base_msg = '{"action": "LONG", "symbol": "' + syminfo.ticker + '"'
        price_msg = ', "price": ' + str.tostring(close)
        grid_msg = ', "grid": ' + str.tostring(gridSizePercent)
        orders_msg = ', "orders": ' + str.tostring(numberOfOrders) + '}'
        alert_msg = base_msg + price_msg + grid_msg + orders_msg
        alert(alert_msg, alert.freq_once_per_bar)
    else if not enableDCA
        base_msg = '{"action": "LONG", "symbol": "' + syminfo.ticker + '"'
        price_msg = ', "price": ' + str.tostring(close) + '}'
        alert_msg = base_msg + price_msg
        alert(alert_msg, alert.freq_once_per_bar)

if final_short_condition
    if enableDCA and sendAlertFirstOrder
        base_msg = '{"action": "SHORT", "symbol": "' + syminfo.ticker + '"'
        price_msg = ', "price": ' + str.tostring(close)
        grid_msg = ', "grid": ' + str.tostring(gridSizePercent)
        orders_msg = ', "orders": ' + str.tostring(numberOfOrders) + '}'
        alert_msg = base_msg + price_msg + grid_msg + orders_msg
        alert(alert_msg, alert.freq_once_per_bar)
    else if not enableDCA
        base_msg = '{"action": "SHORT", "symbol": "' + syminfo.ticker + '"'
        price_msg = ', "price": ' + str.tostring(close) + '}'
        alert_msg = base_msg + price_msg
        alert(alert_msg, alert.freq_once_per_bar)

// Exit alerts
if strategy.position_size[1] != 0 and strategy.position_size == 0
    base_msg = '{"action": "CLOSE", "symbol": "' + syminfo.ticker + '"'
    price_msg = ', "price": ' + str.tostring(close) + '}'
    alert_msg = base_msg + price_msg
    alert(alert_msg, alert.freq_once_per_bar)

// ===============================
// INFORMATION TABLES
// ===============================
// DCA Info Table
if enableDCA
    var table info_table = table.new(position.top_right, 2, 10, bgcolor=color.new(color.black, 90), border_width=1)
    
    if barstate.islast
        table.cell(info_table, 0, 0, "DCA Grid Info", bgcolor=color.blue, text_color=color.white)
        table.cell(info_table, 1, 0, "", bgcolor=color.blue)
        
        table.cell(info_table, 0, 1, "Direction:", text_color=color.white)
        table.cell(info_table, 1, 1, gridDirection, text_color=color.white)
        
        table.cell(info_table, 0, 2, "Grid Size:", text_color=color.white)
        table.cell(info_table, 1, 2, str.tostring(gridSizePercent) + "%", text_color=color.white)
        
        table.cell(info_table, 0, 3, "Orders:", text_color=color.white)
        table.cell(info_table, 1, 3, str.tostring(numberOfOrders), text_color=color.white)
        
        table.cell(info_table, 0, 4, "Martingale:", text_color=color.white)
        table.cell(info_table, 1, 4, str.tostring(martingaleMultiplier), text_color=color.white)
        
        table.cell(info_table, 0, 5, "Current Orders:", text_color=color.white)
        table.cell(info_table, 1, 5, str.tostring(order_count), text_color=color.white)
        
        table.cell(info_table, 0, 6, "Entry Price:", text_color=color.white)
        table.cell(info_table, 1, 6, na(entry_price) ? "N/A" : str.tostring(entry_price, "#.####"), text_color=color.white)
        
        table.cell(info_table, 0, 7, "Avg Price:", text_color=color.white)
        table.cell(info_table, 1, 7, na(avg_price) ? "N/A" : str.tostring(avg_price, "#.####"), text_color=color.white)
        
        table.cell(info_table, 0, 8, "Position:", text_color=color.white)
        table.cell(info_table, 1, 8, str.tostring(strategy.position_size, "#.####"), text_color=color.white)
        
        table.cell(info_table, 0, 9, "P&L:", text_color=color.white)
        table.cell(info_table, 1, 9, str.tostring(strategy.openprofit, "#.##") + "$", 
                  text_color=strategy.openprofit >= 0 ? color.green : color.red)

// Performance Table
var table perf_table = table.new(position.bottom_right, 2, 7, bgcolor=color.new(color.black, 90), border_width=1)

if barstate.islast
    table.cell(perf_table, 0, 0, "Performance", bgcolor=color.blue, text_color=color.white)
    table.cell(perf_table, 1, 0, "", bgcolor=color.blue)
    
    table.cell(perf_table, 0, 1, "Total Trades:", text_color=color.white)
    table.cell(perf_table, 1, 1, str.tostring(strategy.closedtrades), text_color=color.white)
    
    table.cell(perf_table, 0, 2, "Win Rate:", text_color=color.white)
    win_rate = strategy.closedtrades > 0 ? strategy.wintrades / strategy.closedtrades * 100 : 0
    table.cell(perf_table, 1, 2, str.tostring(win_rate, "#.##") + "%", text_color=color.white)
    
    table.cell(perf_table, 0, 3, "Profit Factor:", text_color=color.white)
    profit_factor = strategy.grossloss != 0 ? math.abs(strategy.grossprofit / strategy.grossloss) : 0
    table.cell(perf_table, 1, 3, str.tostring(profit_factor, "#.##"), text_color=color.white)
    
    table.cell(perf_table, 0, 4, "Net Profit:", text_color=color.white)
    table.cell(perf_table, 1, 4, str.tostring(strategy.netprofit, "#.##") + "$", 
              text_color=strategy.netprofit >= 0 ? color.green : color.red)
    
    table.cell(perf_table, 0, 5, "Max DD:", text_color=color.white)
    table.cell(perf_table, 1, 5, str.tostring(strategy.max_drawdown, "#.##") + "$", text_color=color.white)
    
    table.cell(perf_table, 0, 6, "Max DD %:", text_color=color.white)
    max_dd_percent = strategy.initial_capital > 0 ? strategy.max_drawdown / strategy.initial_capital * 100 : 0
    table.cell(perf_table, 1, 6, str.tostring(max_dd_percent, "#.##") + "%", text_color=color.white)

// Active Indicators Table
var table indicators_table = table.new(position.bottom_left, 2, 25, bgcolor=color.new(color.black, 90), border_width=1)

if barstate.islast and showSignals
    table.cell(indicators_table, 0, 0, "Active Indicators", bgcolor=color.green, text_color=color.white)
    table.cell(indicators_table, 1, 0, str.tostring(active_indicators_count), bgcolor=color.green, text_color=color.white)
    
    row = 1
    
    // Show key active indicators with their status
    if useRSI1
        table.cell(indicators_table, 0, row, "RSI1:", text_color=color.white)
        table.cell(indicators_table, 1, row, str.tostring(rsi1_value, "#.#"), text_color=color.white)
        row += 1
    
    if useRSI2
        table.cell(indicators_table, 0, row, "RSI2:", text_color=color.white)
        table.cell(indicators_table, 1, row, str.tostring(rsi2_value, "#.#"), text_color=color.white)
        row += 1
    
    if useRSI3
        table.cell(indicators_table, 0, row, "RSI3:", text_color=color.white)
        table.cell(indicators_table, 1, row, str.tostring(rsi3_value, "#.#"), text_color=color.white)
        row += 1
    
    if useST1
        table.cell(indicators_table, 0, row, "ST1:", text_color=color.white)
        table.cell(indicators_table, 1, row, st1_direction == 1 ? "Bull" : "Bear", 
                  text_color=st1_direction == 1 ? color.green : color.red)
        row += 1
    
    if useST2
        table.cell(indicators_table, 0, row, "ST2:", text_color=color.white)
        table.cell(indicators_table, 1, row, st2_direction == 1 ? "Bull" : "Bear", 
                  text_color=st2_direction == 1 ? color.green : color.red)
        row += 1
    
    if useST3
        table.cell(indicators_table, 0, row, "ST3:", text_color=color.white)
        table.cell(indicators_table, 1, row, st3_direction == 1 ? "Bull" : "Bear", 
                  text_color=st3_direction == 1 ? color.green : color.red)
        row += 1
    
    if useMA
        table.cell(indicators_table, 0, row, "MA:", text_color=color.white)
        table.cell(indicators_table, 1, row, ma_long_signal ? "✓" : "✗", 
                  text_color=ma_long_signal ? color.green : color.red)
        row += 1
    
    if useChannels
        table.cell(indicators_table, 0, row, "Channel:", text_color=color.white)
        table.cell(indicators_table, 1, row, channels_long_signal ? "✓" : "✗", 
                  text_color=channels_long_signal ? color.green : color.red)
        row += 1
    
    if useQQE
        table.cell(indicators_table, 0, row, "QQE:", text_color=color.white)
        qqe_color = color.gray
        qqe_text = "Neutral"
        if qqe_trend == 1
            qqe_color := color.green
            qqe_text := "Bull"
        else if qqe_trend == -1
            qqe_color := color.red
            qqe_text := "Bear"
        table.cell(indicators_table, 1, row, qqe_text, text_color=qqe_color)
        row += 1
    
    if useMACD
        table.cell(indicators_table, 0, row, "MACD:", text_color=color.white)
        table.cell(indicators_table, 1, row, macd_long_signal ? "✓" : "✗", 
                  text_color=macd_long_signal ? color.green : color.red)
        row += 1
    
    // Summary
    table.cell(indicators_table, 0, row + 1, "All Met:", text_color=color.white)
    all_met = all_long_signals or all_short_signals
    table.cell(indicators_table, 1, row + 1, all_met ? "YES" : "NO", 
              text_color=all_met ? color.green : color.red)

// ===============================
// CSV EXPORT/IMPORT - FIXED SYNTAX
// ===============================
// Generate CSV export string
if export_button and barstate.islast
    csv_str = ""
    // Basic settings
    csv_str += "showTPSL," + str.tostring(showTPSL ? 1 : 0) + "\n"
    csv_str += "showSignals," + str.tostring(showSignals ? 1 : 0) + "\n"
    csv_str += "startYear," + str.tostring(startYear) + "\n"
    csv_str += "stopYear," + str.tostring(stopYear) + "\n"
    csv_str += "enableDCA," + str.tostring(enableDCA ? 1 : 0) + "\n"
    csv_str += "gridDirection," + gridDirection + "\n"
    csv_str += "depositForBot," + str.tostring(depositForBot) + "\n"
    csv_str += "leverage," + str.tostring(leverage) + "\n"
    csv_str += "gridSizePercent," + str.tostring(gridSizePercent) + "\n"
    csv_str += "numberOfOrders," + str.tostring(numberOfOrders) + "\n"
    csv_str += "martingaleMultiplier," + str.tostring(martingaleMultiplier) + "\n"
    csv_str += "useLong," + str.tostring(useLong ? 1 : 0) + "\n"
    csv_str += "useShort," + str.tostring(useShort ? 1 : 0) + "\n"
    csv_str += "takeProfitPercent," + str.tostring(takeProfitPercent) + "\n"
    csv_str += "stopLossPercent," + str.tostring(stopLossPercent) + "\n"
    csv_str += "useBreakeven," + str.tostring(useBreakeven ? 1 : 0) + "\n"
    csv_str += "breakevenActivation," + str.tostring(breakevenActivation) + "\n"
    csv_str += "useTrailingStop," + str.tostring(useTrailingStop ? 1 : 0) + "\n"
    csv_str += "trailingActivation," + str.tostring(trailingActivation) + "\n"
    csv_str += "trailingDistance," + str.tostring(trailingDistance) + "\n"
    
    // RSI Indicators - ALL 3 instances
    csv_str += "useRSI1," + str.tostring(useRSI1 ? 1 : 0) + "\n"
    csv_str += "rsi1_length," + str.tostring(rsi1_length) + "\n"
    csv_str += "rsi1_overbought," + str.tostring(rsi1_overbought) + "\n"
    csv_str += "rsi1_oversold," + str.tostring(rsi1_oversold) + "\n"
    csv_str += "useRSI2," + str.tostring(useRSI2 ? 1 : 0) + "\n"
    csv_str += "rsi2_length," + str.tostring(rsi2_length) + "\n"
    csv_str += "useRSI3," + str.tostring(useRSI3 ? 1 : 0) + "\n"
    csv_str += "rsi3_length," + str.tostring(rsi3_length) + "\n"
    
    // SuperTrend Indicators - ALL 3 instances + legacy
    csv_str += "useST1," + str.tostring(useST1 ? 1 : 0) + "\n"
    csv_str += "st1_period," + str.tostring(st1_period) + "\n"
    csv_str += "st1_factor," + str.tostring(st1_factor) + "\n"
    csv_str += "useST2," + str.tostring(useST2 ? 1 : 0) + "\n"
    csv_str += "useST3," + str.tostring(useST3 ? 1 : 0) + "\n"
    csv_str += "useSupertrend," + str.tostring(useSupertrend ? 1 : 0) + "\n"
    
    // Core indicators
    csv_str += "useMA," + str.tostring(useMA ? 1 : 0) + "\n"
    csv_str += "ma_fast_length," + str.tostring(ma_fast_length) + "\n"
    csv_str += "ma_slow_length," + str.tostring(ma_slow_length) + "\n"
    csv_str += "ma_fast_type," + ma_fast_type + "\n"
    csv_str += "ma_slow_type," + ma_slow_type + "\n"
    csv_str += "useChannels," + str.tostring(useChannels ? 1 : 0) + "\n"
    csv_str += "channel_type," + channel_type + "\n"
    csv_str += "channel_length," + str.tostring(channel_length) + "\n"
    csv_str += "channel_multiplier," + str.tostring(channel_multiplier) + "\n"
    csv_str += "useQQE," + str.tostring(useQQE ? 1 : 0) + "\n"
    csv_str += "qqe_rsi_length," + str.tostring(qqe_rsi_length) + "\n"
    csv_str += "useMACD," + str.tostring(useMACD ? 1 : 0) + "\n"
    csv_str += "macd_fast_length," + str.tostring(macd_fast_length) + "\n"
    csv_str += "macd_slow_length," + str.tostring(macd_slow_length) + "\n"
    csv_str += "macd_signal_length," + str.tostring(macd_signal_length) + "\n"
    
    // Additional indicators
    csv_str += "useStochastic," + str.tostring(useStochastic ? 1 : 0) + "\n"
    csv_str += "useMFI," + str.tostring(useMFI ? 1 : 0) + "\n"
    csv_str += "useCCI," + str.tostring(useCCI ? 1 : 0) + "\n"
    csv_str += "useDMI," + str.tostring(useDMI ? 1 : 0) + "\n"
    csv_str += "useChaikin," + str.tostring(useChaikin ? 1 : 0) + "\n"
    csv_str += "useBOP," + str.tostring(useBOP ? 1 : 0) + "\n"
    csv_str += "useDivergence," + str.tostring(useDivergence ? 1 : 0) + "\n"
    csv_str += "useCandlePatterns," + str.tostring(useCandlePatterns ? 1 : 0) + "\n"
    csv_str += "useLRC," + str.tostring(useLRC ? 1 : 0) + "\n"
    csv_str += "useExternal," + str.tostring(useExternal ? 1 : 0) + "\n"
    
    // Display export CSV
    var table export_table = table.new(position.middle_center, 1, 2, bgcolor=color.new(color.black, 80))
    table.cell(export_table, 0, 0, "CSV Export (Copy this):", text_color=color.yellow, text_size=size.normal)
    table.cell(export_table, 0, 1, csv_str, text_color=color.white, text_size=size.small)

// Display export hint
if show_export and barstate.islast
    var table hint_table = table.new(position.middle_center, 1, 1, bgcolor=color.new(color.blue, 80))
    table.cell(hint_table, 0, 0, "Enable 'Generate Export String' to see CSV", text_color=color.white, text_size=size.normal)

// ================================
// END OF STRATEGY
// ================================
