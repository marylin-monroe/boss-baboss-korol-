//@version=5
strategy("boss/baboss [korol]", 
         shorttitle="BABOSS", 
         overlay=true, 
         pyramiding=20, 
         default_qty_type=strategy.percent_of_equity, 
         default_qty_value=5, 
         initial_capital=10000, 
         commission_type=strategy.commission.percent, 
         commission_value=0.1,
         calc_on_order_fills=true,
         calc_on_every_tick=false,
         max_labels_count=500,
         max_lines_count=500,
         max_bars_back=5000,
         process_orders_on_close=true,
         use_bar_magnifier=false)

// ===============================
// CSV IMPORT/EXPORT FUNCTIONALITY
// ===============================
csv_group = "═══════════ CSV Import/Export ═══════════"
csv_string = input.text_area("", "Paste CSV String Here (for import)", group=csv_group)
show_export = input.bool(false, "Show Export String", group=csv_group)
export_button = input.bool(false, "Generate Export String", group=csv_group)

// ===============================
// HELPER FUNCTIONS
// ===============================
// Enhanced Moving Average Function with all types - Fixed
ma_function(src, length, ma_type) =>
    result = 0.0
    if ma_type == "SMA"
        result := ta.sma(src, length)
    else if ma_type == "EMA"
        result := ta.ema(src, length)
    else if ma_type == "RMA"
        result := ta.rma(src, length)
    else if ma_type == "WMA"
        result := ta.wma(src, length)
    else if ma_type == "HMA"
        result := ta.hma(src, length)
    else if ma_type == "VWMA"
        result := ta.vwma(src, length)
    else if ma_type == "TEMA"
        ema1 = ta.ema(src, length)
        ema2 = ta.ema(ema1, length)
        ema3 = ta.ema(ema2, length)
        result := 3 * (ema1 - ema2) + ema3
    else if ma_type == "DEMA"
        ema1 = ta.ema(src, length)
        ema2 = ta.ema(ema1, length)
        result := 2 * ema1 - ema2
    else
        result := ta.ema(src, length)
    result

// ===============================
// VISUALIZATION SETTINGS
// ===============================
viz_group = "═══════════ Visualization ═══════════"
showTPSL = input.bool(true, "Display Visualisation for TP/SL ?", group=viz_group)
showSignals = input.bool(true, "Show Signals ?", group=viz_group)
showLastSignalLines = input.bool(false, "Show Last Signal Lines ?", group=viz_group)
visualizeTrailingActivation = input.bool(false, "Visualise Trailing Activation Price ?", group=viz_group)

// ===============================
// PERIOD AND DAYS SETTINGS
// ===============================
period_group = "═══════════ Period Settings ═══════════"
startYear = input.int(2022, "Start Year", minval=2000, maxval=2100, group=period_group)
stopYear = input.int(2025, "Stop Year", minval=2000, maxval=2100, group=period_group)

days_group = "═══════════ Days To Block ═══════════"
blockSu = input.bool(false, "Su", group=days_group, inline="days1")
blockMo = input.bool(false, "Mo", group=days_group, inline="days1") 
blockTu = input.bool(false, "Tu", group=days_group, inline="days1")
blockWe = input.bool(false, "We", group=days_group, inline="days1")
blockTh = input.bool(false, "Th", group=days_group, inline="days2")
blockFr = input.bool(false, "Fr", group=days_group, inline="days2")
blockSa = input.bool(false, "Sa", group=days_group, inline="days2")

// ===============================
// DCA GRID SETTINGS
// ===============================
dca_group = "═══════════ DCA Grid Settings ═══════════"
enableDCA = input.bool(true, "Activate DCA Grid ?", group=dca_group)
gridDirection = input.string("Long", "Long or Short Grid ?", options=["Long", "Short"], group=dca_group)
depositForBot = input.float(50, "Deposit for Bot (for the entire grid) ($)", minval=1, group=dca_group)
leverage = input.int(20, "Leverage (1x-20x)", minval=1, maxval=20, group=dca_group)
gridSizePercent = input.float(2.9, "Grid Size (%)", minval=0.1, maxval=50.0, step=0.1, group=dca_group)
numberOfOrders = input.int(4, "Number of orders in the grid (3-15)", minval=3, maxval=15, group=dca_group)
martingaleMultiplier = input.float(1.05, "Orders Value Martingale (1.0-1.8)", minval=1.0, maxval=1.8, step=0.01, group=dca_group)
logarithmicSteps = input.float(0.9, "Logarithmic Orders Steps (0.8-1.4)", minval=0.8, maxval=1.4, step=0.1, group=dca_group)
closeOnBigDrawdown = input.bool(false, "Close All Orders on Big Drawdown ?", group=dca_group)
drawdownToClose = input.float(-95, "Drawdown to close (-$)", group=dca_group)
changeTakeProfit = input.bool(false, "Change Take Profit if Many Orders ?", group=dca_group)
newTakeProfitPercent = input.float(1.25, "Set Take Profit to X%", minval=0.1, maxval=5.0, step=0.01, group=dca_group)
ifOrdersMoreThan = input.int(3, "If Orders more than N", minval=2, maxval=15, group=dca_group)
sendAlertFirstOrder = input.bool(true, "Send Alert only for First Order", group=dca_group)

// ===============================
// DIRECTION AND TP/SL SETTINGS
// ===============================
dir_group = "═══════════ Direction ═══════════"
useLong = input.bool(true, "Use Long ?", group=dir_group)
useShort = input.bool(false, "Use Short ?", group=dir_group)

tpsl_group = "═══════════ TP/SL Settings ═══════════"
takeProfitPercent = input.float(2.1, "Take Profit (%)", minval=0.1, maxval=20.0, step=0.1, group=tpsl_group)
stopLossPercent = input.float(1.4, "Stop Loss (%)", minval=0.1, maxval=50.0, step=0.1, group=tpsl_group)
slEqualsTp = input.bool(false, "SL=TP ? (for optimization)", group=tpsl_group)
close_static_tp_sl = input.bool(true, "Close on Static TP/SL", group=tpsl_group)
closeOnlyInProfit = input.bool(false, "Close only in Profit. (Used only for \"Close Conditions\")", group=tpsl_group)

// Reverse Orders
useReverseOrderOnSL = input.bool(false, "Reverse order on SL", group=tpsl_group)
useReverseOrderOnBE = input.bool(false, "Reverse order on BE", group=tpsl_group)

// ===============================
// BREAKEVEN SETTINGS
// ===============================
be_group = "═══════════ Breakeven ═══════════"
useBreakeven = input.bool(false, "Activate Breakeven ?", group=be_group)
breakevenActivation = input.float(0.9, "(%) to Activate Breakeven", minval=0.1, maxval=10.0, step=0.01, group=be_group)
breakevenLevel = input.float(0.01, "New Breakeven SL (%)", minval=0.0, maxval=5.0, step=0.01, group=be_group)

// ===============================
// MULTI TAKE PROFITS
// ===============================
mtp_group = "═══════════ Multi Take Profits ═══════════"
useMultiTP = input.bool(false, "Use Multiple Take Profits ?", group=mtp_group)
tp1_percent = input.float(0.6, "Profit Percent for 1 TP (%)", minval=0.1, maxval=10.0, step=0.1, group=mtp_group)
tp1_qty = input.int(15, "Value of 1 TP (%)", minval=10, maxval=90, group=mtp_group)
tp2_percent = input.float(0.8, "Profit Percent for 2 TP (%)", minval=0.1, maxval=15.0, step=0.1, group=mtp_group)
tp2_qty = input.int(15, "Value of 2 TP (%)", minval=10, maxval=90, group=mtp_group)
tp3_percent = input.float(1.0, "Profit Percent for 3 TP (%)", minval=0.1, maxval=20.0, step=0.1, group=mtp_group)
tp3_qty = input.int(15, "Value of 3 TP (%)", minval=10, maxval=90, group=mtp_group)
tp4_percent = input.float(1.4, "Profit Percent for 4 TP (%)", minval=0.1, maxval=30.0, step=0.1, group=mtp_group)
tp4_qty = input.int(100, "Value of 4 TP (%) (Always All Remained)", minval=10, maxval=100, group=mtp_group)

// ===============================
// PYRAMIDING SETTINGS
// ===============================
pyr_group = "═══════════ Pyramiding ═══════════"
usePyramiding = input.bool(false, "Use Averaging ? (Pyramiding)", group=pyr_group)
pyramidMinMove = input.float(0.5, "Min price move for averaging (%)", minval=0.1, maxval=5.0, step=0.1, group=pyr_group)

// ===============================
// TRAILING STOP
// ===============================
trail_group = "═══════════ Trailing Stop ═══════════"
useTrailingStop = input.bool(false, "Use Trailing Stop ? Read Warning ->", group=trail_group)
trailingActivation = input.float(1.5, "Activate Trailing Stop at %", minval=0.1, maxval=10.0, step=0.1, group=trail_group)
trailingDistance = input.float(0.5, "Distance from price to Trailing Stop (%)", minval=0.1, maxval=5.0, step=0.1, group=trail_group)

// ===============================
// ORDER INDENT
// ===============================
indent_group = "═══════════ Order Indent ═══════════"
useOrderIndent = input.bool(false, "Use Indent Order ?", group=indent_group)
indentPercent = input.float(0.1, "Indent in % (0.1)", minval=-2.0, maxval=2.0, step=0.01, group=indent_group)
indentCancelBars = input.int(15, "Cancel Indent Order (if not executed) After X Bars", minval=1, maxval=50, group=indent_group)

// ===============================
// ATR STOP LOSS AND TAKE PROFIT
// ===============================
atr_group = "═══════════ ATR SL/TP ═══════════"
useATRStopLoss = input.bool(false, "Use ATR Stop Loss", group=atr_group)
atr_sl_length = input.int(14, "ATR SL Length", minval=1, maxval=50, group=atr_group)
atr_sl_multiplier = input.float(2.0, "ATR SL Multiplier", minval=0.5, maxval=10.0, step=0.1, group=atr_group)

useATRTakeProfit = input.bool(false, "Use ATR Take Profit", group=atr_group)
atr_tp_length = input.int(14, "ATR TP Length", minval=1, maxval=50, group=atr_group)
atr_tp_multiplier = input.float(2.0, "ATR TP Multiplier", minval=0.5, maxval=10.0, step=0.1, group=atr_group)

// ===============================
// VOLUME AND VOLATILITY FILTERS
// ===============================
vol_filter_group = "═══════════ Volume Filter ═══════════"
useVolumeFilter = input.bool(false, "Use Volume Filter", group=vol_filter_group)
volume_length = input.int(20, "Volume Length", minval=5, maxval=100, group=vol_filter_group)
volume_multiplier = input.float(1.5, "Volume Multiplier", minval=0.5, maxval=5.0, step=0.1, group=vol_filter_group)
volume_condition = input.string("Above Average", "Volume Condition", options=["Above Average", "Below Average", "Rising", "Falling"], group=vol_filter_group)

volat_filter_group = "═══════════ Volatility Filter ═══════════"
useVolatilityFilter = input.bool(false, "Use Volatility Filter", group=volat_filter_group)
vol_length = input.int(20, "Volatility Length", minval=5, maxval=100, group=volat_filter_group)
vol_threshold = input.float(1.0, "Volatility Threshold", minval=0.1, maxval=10.0, step=0.1, group=volat_filter_group)
vol_condition = input.string("Rising", "Volatility Condition", options=["Rising", "Falling", "Above Level", "Below Level"], group=volat_filter_group)

// ===============================
// HIGH/LOW PERIOD FILTER
// ===============================
hl_filter_group = "═══════════ High/Low Filter ═══════════"
useHighLowFilter = input.bool(false, "Use Highest/Lowest Filter", group=hl_filter_group)
highlow_period = input.int(20, "Period for High/Low", minval=5, maxval=200, group=hl_filter_group)
highlow_min_change = input.float(2.0, "Min Change % for Signal", minval=0.1, maxval=10.0, step=0.1, group=hl_filter_group)

// ===============================
// ATR CHANGE FILTER
// ===============================
atr_change_group = "═══════════ ATR Change Filter ═══════════"
useATRChangeFilter = input.bool(false, "Use ATR Change Filter", group=atr_change_group)
atr_change_period = input.int(20, "ATR Period for Comparison", minval=5, maxval=100, group=atr_change_group)
atr_change_threshold = input.float(10.0, "Min ATR Change %", minval=1.0, maxval=50.0, step=1.0, group=atr_change_group)

// ===============================
// BLOCK IF WORSE THAN
// ===============================
block_filter_group = "═══════════ Block Filter ═══════════"
useBlockIfWorse = input.bool(false, "Block if Worse Than", group=block_filter_group)
blockIfWorsePercent = input.float(0.5, "Block if price moved X% in our direction", minval=0.1, maxval=5.0, step=0.1, group=block_filter_group)

// ===============================
// PINBAR + MA SIGNAL
// ===============================
pinbar_group = "═══════════ PinBar+MA ═══════════"
usePinBarMA = input.bool(false, "Use PinBar + MA Signal", group=pinbar_group)
pinbar_ma1_length = input.int(10, "MA1 Length", minval=2, maxval=100, group=pinbar_group)
pinbar_ma2_length = input.int(20, "MA2 Length", minval=2, maxval=100, group=pinbar_group)
pinbar_ma3_length = input.int(50, "MA3 Length", minval=2, maxval=100, group=pinbar_group)
pinbar_ratio = input.float(2.0, "Pin Bar Ratio", minval=1.5, maxval=5.0, step=0.1, group=pinbar_group)

// ===============================
// SUPERTREND FILTER
// ===============================
st_group = "═══════════ Supertrend ═══════════"
useSupertrend = input.bool(false, "Use Supertrend Filter", group=st_group)
supertrend_period = input.int(10, "Supertrend Period", minval=1, maxval=50, group=st_group)
supertrend_factor = input.float(3.0, "Supertrend Factor", minval=0.5, maxval=10.0, step=0.1, group=st_group)

// ===============================
// CONSOLIDATION ZONES
// ===============================
consol_group = "═══════════ Consolidation ═══════════"
useConsolidation = input.bool(false, "Use Consolidation Zones", group=consol_group)
consolidation_length = input.int(20, "Consolidation Length", minval=5, maxval=100, group=consol_group)
consolidation_range = input.float(1.0, "Max Range % for Consolidation", minval=0.1, maxval=5.0, step=0.1, group=consol_group)

// ===============================
// MOVING AVERAGES
// ===============================
ma_group = "═══════════ Moving Averages ═══════════"
useMA = input.bool(false, "Use Moving Averages", group=ma_group)
ma_fast_length = input.int(10, "Fast MA Length", minval=2, maxval=200, group=ma_group)
ma_slow_length = input.int(30, "Slow MA Length", minval=2, maxval=200, group=ma_group)
ma_fast_type = input.string("EMA", "Fast MA Type", options=["SMA", "EMA", "RMA", "WMA", "HMA", "VWMA", "TEMA", "DEMA"], group=ma_group)
ma_slow_type = input.string("EMA", "Slow MA Type", options=["SMA", "EMA", "RMA", "WMA", "HMA", "VWMA", "TEMA", "DEMA"], group=ma_group)
ma_signal_type = input.string("Cross", "MA Signal Type", options=["Cross", "Direction", "Both Direction Same"], group=ma_group)
ma_signal_memory = input.bool(false, "Activate Signal Memory", group=ma_group)
ma_memory_bars = input.int(5, "Signal Memory Bars", minval=1, maxval=20, group=ma_group)

// ===============================
// CHANNELS (BB/KC)
// ===============================
channel_group = "═══════════ Channels ═══════════"
useChannels = input.bool(false, "Use Channels", group=channel_group)
channel_type = input.string("Bollinger Bands", "Channel Type", options=["Bollinger Bands", "Keltner Channel"], group=channel_group)
channel_length = input.int(20, "Channel Length", minval=5, maxval=100, group=channel_group)
channel_multiplier = input.float(2.0, "Channel Multiplier", minval=0.5, maxval=5.0, step=0.1, group=channel_group)
channel_signal_type = input.string("Touch", "Channel Signal", options=["Touch", "Close Outside", "Breakout"], group=channel_group)

// ===============================
// RSI SETTINGS
// ===============================
rsi_group = "═══════════ RSI ═══════════"
useRSI1 = input.bool(false, "Use RSI", group=rsi_group)
rsi1_length = input.int(14, "RSI Length", minval=2, maxval=100, group=rsi_group)
rsi1_overbought = input.float(70, "RSI Overbought", minval=50, maxval=90, group=rsi_group)
rsi1_oversold = input.float(30, "RSI Oversold", minval=10, maxval=50, group=rsi_group)

// ===============================
// RVI SETTINGS
// ===============================
rvi_group = "═══════════ RVI ═══════════"
useRVI = input.bool(false, "Use RVI", group=rvi_group)
rvi_length = input.int(10, "RVI Length", minval=2, maxval=100, group=rvi_group)
rvi_overbought = input.float(0.4, "RVI Overbought", minval=0.1, maxval=0.9, step=0.1, group=rvi_group)
rvi_oversold = input.float(-0.4, "RVI Oversold", minval=-0.9, maxval=-0.1, step=0.1, group=rvi_group)

// ===============================
// MFI SETTINGS
// ===============================
mfi_group = "═══════════ MFI ═══════════"
useMFI = input.bool(false, "Use MFI", group=mfi_group)
mfi_length = input.int(14, "MFI Length", minval=2, maxval=100, group=mfi_group)
mfi_overbought = input.float(80, "MFI Overbought", minval=50, maxval=90, group=mfi_group)
mfi_oversold = input.float(20, "MFI Oversold", minval=10, maxval=50, group=mfi_group)

// ===============================
// CCI SETTINGS
// ===============================
cci_group = "═══════════ CCI ═══════════"
useCCI = input.bool(false, "Use CCI", group=cci_group)
cci_length = input.int(20, "CCI Length", minval=5, maxval=200, group=cci_group)
cci_overbought = input.float(100, "CCI Overbought", minval=50, maxval=200, group=cci_group)
cci_oversold = input.float(-100, "CCI Oversold", minval=-200, maxval=-50, group=cci_group)

// ===============================
// MOMENTUM SETTINGS
// ===============================
mom_group = "═══════════ Momentum ═══════════"
useMomentum = input.bool(false, "Use Momentum", group=mom_group)
momentum_length = input.int(10, "Momentum Length", minval=2, maxval=100, group=mom_group)
momentum_overbought = input.float(0.5, "Momentum Overbought", minval=0.1, maxval=2.0, step=0.1, group=mom_group)
momentum_oversold = input.float(-0.5, "Momentum Oversold", minval=-2.0, maxval=-0.1, step=0.1, group=mom_group)

// ===============================
// DYNAMIC RSI
// ===============================
drsi_group = "═══════════ Dynamic RSI ═══════════"
useDynamicRSI = input.bool(false, "Use Dynamic RSI", group=drsi_group)
drsi_length = input.int(14, "Dynamic RSI Length", minval=2, maxval=100, group=drsi_group)
drsi_band_length = input.int(20, "Band Length", minval=5, maxval=100, group=drsi_group)
drsi_band_mult = input.float(2.0, "Band Multiplier", minval=1.0, maxval=5.0, step=0.1, group=drsi_group)

// ===============================
// DYNAMIC MFI
// ===============================
dmfi_group = "═══════════ Dynamic MFI ═══════════"
useDynamicMFI = input.bool(false, "Use Dynamic MFI", group=dmfi_group)
dmfi_length = input.int(14, "Dynamic MFI Length", minval=2, maxval=100, group=dmfi_group)
dmfi_band_length = input.int(20, "Band Length", minval=5, maxval=100, group=dmfi_group)
dmfi_band_mult = input.float(2.0, "Band Multiplier", minval=1.0, maxval=5.0, step=0.1, group=dmfi_group)

// ===============================
// SMI ERGODIC OSCILLATOR
// ===============================
smi_group = "═══════════ SMI Ergodic ═══════════"
useSMIO = input.bool(false, "Use SMI Ergodic", group=smi_group)
smio_short_length = input.int(5, "Short Length", minval=2, maxval=50, group=smi_group)
smio_long_length = input.int(20, "Long Length", minval=5, maxval=100, group=smi_group)
smio_signal_length = input.int(5, "Signal Length", minval=2, maxval=50, group=smi_group)
smio_overbought = input.float(0.5, "Overbought", minval=0.1, maxval=1.0, step=0.1, group=smi_group)
smio_oversold = input.float(-0.5, "Oversold", minval=-1.0, maxval=-0.1, step=0.1, group=smi_group)

// ===============================
// DMI SETTINGS
// ===============================
dmi_group = "═══════════ DMI ═══════════"
useDMI = input.bool(false, "Use DMI", group=dmi_group)
dmi_length = input.int(14, "DMI Length", minval=5, maxval=50, group=dmi_group)
dmi_adx_threshold = input.float(25, "ADX Threshold", minval=10, maxval=50, group=dmi_group)
dmi_signal_type = input.string("DI Cross", "DMI Signal", options=["DI Cross", "ADX Level", "Both"], group=dmi_group)

// ===============================
// CHAIKIN MONEY FLOW
// ===============================
chaikin_group = "═══════════ Chaikin MF ═══════════"
useChaikin = input.bool(false, "Use Chaikin Money Flow", group=chaikin_group)
chaikin_length = input.int(20, "Chaikin Length", minval=5, maxval=100, group=chaikin_group)
chaikin_overbought = input.float(0.2, "Overbought", minval=0.1, maxval=0.5, step=0.05, group=chaikin_group)
chaikin_oversold = input.float(-0.2, "Oversold", minval=-0.5, maxval=-0.1, step=0.05, group=chaikin_group)
chaikin_use_zero = input.bool(true, "Use Zero Cross Signal", group=chaikin_group)

// ===============================
// BALANCE OF POWER
// ===============================
bop_group = "═══════════ Balance of Power ═══════════"
useBOP = input.bool(false, "Use Balance of Power", group=bop_group)
bop_smooth_length = input.int(14, "Smoothing Length", minval=1, maxval=50, group=bop_group)
bop_overbought = input.float(0.5, "Overbought", minval=0.1, maxval=1.0, step=0.1, group=bop_group)
bop_oversold = input.float(-0.5, "Oversold", minval=-1.0, maxval=-0.1, step=0.1, group=bop_group)
bop_use_zero = input.bool(true, "Use Zero Cross Signal", group=bop_group)

// ===============================
// MACD SETTINGS
// ===============================
macd_group = "═══════════ MACD ═══════════"
useMACD = input.bool(false, "Use MACD", group=macd_group)
macd_fast_length = input.int(12, "Fast Length", minval=2, maxval=50, group=macd_group)
macd_slow_length = input.int(26, "Slow Length", minval=5, maxval=100, group=macd_group)
macd_signal_length = input.int(9, "Signal Length", minval=2, maxval=50, group=macd_group)
macd_signal_type = input.string("Signal Cross", "MACD Signal", options=["Signal Cross", "Zero Cross", "Both"], group=macd_group)
macd_signal_memory = input.bool(true, "Activate Signal Memory", group=macd_group)
macd_memory_bars = input.int(5, "Signal Memory Bars", minval=1, maxval=20, group=macd_group)

// ===============================
// LEVELS (SUPPORT/RESISTANCE)
// ===============================
levels_group = "═══════════ Levels ═══════════"
useLevels = input.bool(false, "Use Levels", group=levels_group)
level_lookback = input.int(50, "Lookback Period", minval=10, maxval=200, group=levels_group)
level_proximity = input.float(0.5, "Proximity to Level %", minval=0.1, maxval=2.0, step=0.1, group=levels_group)
level_min_touches = input.int(3, "Min Touches for Level", minval=2, maxval=10, group=levels_group)

// ===============================
// QQE SIGNALS
// ===============================
qqe_group = "═══════════ QQE ═══════════"
useQQE = input.bool(false, "Use QQE Signals", group=qqe_group)
qqe_rsi_length = input.int(14, "RSI Length", minval=2, maxval=100, group=qqe_group)
qqe_smoothing = input.int(5, "Smoothing", minval=1, maxval=50, group=qqe_group)
qqe_factor = input.float(4.236, "QQE Factor", minval=1.0, maxval=10.0, step=0.1, group=qqe_group)

// ===============================
// DIVERGENCES
// ===============================
div_group = "═══════════ Divergences ═══════════"
useDivergence = input.bool(false, "Use Divergences", group=div_group)
div_lookback = input.int(50, "Lookback Period", minval=10, maxval=100, group=div_group)
div_rsi = input.bool(true, "Check RSI Divergence", group=div_group)
div_macd = input.bool(true, "Check MACD Divergence", group=div_group)
div_mfi = input.bool(true, "Check MFI Divergence", group=div_group)
div_cci = input.bool(true, "Check CCI Divergence", group=div_group)
div_momentum = input.bool(true, "Check Momentum Divergence", group=div_group)
div_obv = input.bool(true, "Check OBV Divergence", group=div_group)

// ===============================
// CANDLE PATTERNS
// ===============================
candle_group = "═══════════ Candle Patterns ═══════════"
useCandlePatterns = input.bool(false, "Use Candle Patterns", group=candle_group)
use_hammer = input.bool(true, "Hammer/Hanging Man", group=candle_group)
use_engulfing = input.bool(true, "Engulfing", group=candle_group)
use_doji = input.bool(true, "Doji", group=candle_group)
use_morning_evening_star = input.bool(true, "Morning/Evening Star", group=candle_group)
use_three_soldiers_crows = input.bool(true, "Three Soldiers/Crows", group=candle_group)

// ===============================
// LINEAR REGRESSION CHANNEL
// ===============================
lrc_group = "═══════════ LRC ═══════════"
useLRC = input.bool(false, "Use Linear Regression Channel", group=lrc_group)
lrc_length = input.int(100, "LRC Length", minval=20, maxval=500, group=lrc_group)
lrc_deviation = input.float(2.0, "Deviation", minval=0.5, maxval=5.0, step=0.1, group=lrc_group)

// ===============================
// EXTERNAL INDICATORS
// ===============================
ext_group = "═══════════ External ═══════════"
useExternal = input.bool(false, "Use External Indicator", group=ext_group)
external_source = input.source(close, "External Source", group=ext_group)
external_condition = input.string("Above", "Condition", options=["Above", "Below", "Cross Up", "Cross Down"], group=ext_group)
external_level = input.float(0, "Level", group=ext_group)

// ===============================
// CLOSE CONDITIONS
// ===============================
close_group = "═══════════ Close Signals ═══════════"
close_parabolic_sar = input.bool(false, "Use Parabolic SAR Close", group=close_group)
close_lrc = input.bool(false, "Use LRC Close Signal", group=close_group)
close_bb_kc = input.bool(false, "Use Channel Close Signal", group=close_group)
close_qqe = input.bool(false, "Use QQE Close Signal", group=close_group)
close_rsi = input.bool(false, "Use RSI Close Signal", group=close_group)
close_ma_cross = input.bool(false, "Use MA Cross Close Signal", group=close_group)

// Parabolic SAR settings
sar_start = input.float(0.02, "SAR Start", minval=0.01, maxval=0.1, step=0.01, group=close_group)
sar_increment = input.float(0.02, "SAR Increment", minval=0.01, maxval=0.1, step=0.01, group=close_group)
sar_maximum = input.float(0.2, "SAR Maximum", minval=0.1, maxval=1.0, step=0.1, group=close_group)

// ===============================
// CALCULATION FUNCTIONS
// ===============================
// Bollinger Bands
bollinger_bands(src, length, mult) =>
    basis = ta.sma(src, length)
    dev = mult * ta.stdev(src, length)
    [basis + dev, basis, basis - dev]

// Keltner Channel
keltner_channel(src, length, mult) =>
    basis = ta.ema(src, length)
    range_val = ta.atr(length)
    [basis + range_val * mult, basis, basis - range_val * mult]

// Supertrend - Fixed for Pine Script v5
supertrend(factor, period) =>
    src = hl2
    atr = ta.atr(period)
    upperBand = src + factor * atr
    lowerBand = src - factor * atr
    
    prevLowerBand = nz(lowerBand[1])
    prevUpperBand = nz(upperBand[1])
    
    lb = lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
    ub = upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand
    
    int direction = na
    float superTrend = na
    
    prevSuperTrend = superTrend[1]
    if na(prevSuperTrend)
        direction := 1
    else
        if prevSuperTrend == prevUpperBand
            direction := close <= ub ? -1 : 1
        else
            direction := close >= lb ? 1 : -1
    
    superTrend := direction == -1 ? ub : lb
    [direction, superTrend, ub, lb]

// RVI Calculation
calculate_rvi(length) =>
    numerator = ta.sma(close - open, length)
    denominator = ta.sma(high - low, length)
    rvi = denominator == 0 ? 0 : numerator / denominator
    signal = ta.sma(rvi, 4)
    [rvi, signal]

// SMI Ergodic Oscillator
smi_ergodic(shortLength, longLength, signalLength) =>
    price = close
    highestHigh = ta.highest(high, longLength)
    lowestLow = ta.lowest(low, longLength)
    
    priceChangeEMA = ta.ema(ta.ema(price - 0.5 * (highestHigh + lowestLow), shortLength), shortLength)
    rangeEMA = ta.ema(ta.ema(0.5 * (highestHigh - lowestLow), shortLength), shortLength)
    
    smi = rangeEMA != 0 ? priceChangeEMA / rangeEMA : 0
    signal = ta.ema(smi, signalLength)
    
    [smi, signal]
// QQE Calculation - Fixed for Pine Script v5
var float qqe_longband = 0.0
var float qqe_shortband = 0.0
var int qqe_trend_state = 0

calculate_qqe(src, length, smoothing, factor) =>
    rsi_val = ta.rsi(src, length)
    rsi_ma = ta.ema(rsi_val, smoothing)
    
    atr_rsi = ta.ema(math.abs(rsi_ma[1] - rsi_ma), smoothing)
    dar = ta.ema(atr_rsi, smoothing) * factor
    
    newlongband = rsi_ma - dar
    newshortband = rsi_ma + dar
    
    longband_result = 0.0
    shortband_result = 0.0
    
    if rsi_ma[1] > qqe_longband and rsi_ma > qqe_longband
        longband_result := math.max(qqe_longband, newlongband)
    else
        longband_result := newlongband
    
    if rsi_ma[1] < qqe_shortband and rsi_ma < qqe_shortband
        shortband_result := math.min(qqe_shortband, newshortband)
    else
        shortband_result := newshortband
    
    cross_1 = ta.cross(longband_result, rsi_ma)
    cross_2 = ta.cross(rsi_ma, shortband_result)
    
    trend_result = 0
    if cross_2
        trend_result := 1
    else if cross_1
        trend_result := -1
    else
        trend_result := qqe_trend_state
    
    [rsi_ma, longband_result, shortband_result, trend_result]

// Dynamic Bands
dynamic_bands(value, length, mult) =>
    basis = ta.sma(value, length)
    dev = mult * ta.stdev(value, length)
    [basis + dev, basis - dev]

// Balance of Power
calculate_bop() =>
    bop_raw = high - low == 0 ? 0 : (close - open) / (high - low)
    ta.sma(bop_raw, bop_smooth_length)

// Chaikin Money Flow
calculate_cmf(length) =>
    mfv = ((close - low) - (high - close)) / (high - low) * volume
    ta.sma(mfv, length) / ta.sma(volume, length)

// Candle Pattern Functions
is_hammer() =>
    body = math.abs(close - open)
    lower_shadow = open > close ? close - low : open - low
    upper_shadow = open > close ? high - open : high - close
    lower_shadow >= body * 2 and upper_shadow <= body * 0.5

is_bullish_engulfing() =>
    close[1] < open[1] and close > open and open <= close[1] and close >= open[1]

is_bearish_engulfing() =>
    close[1] > open[1] and close < open and open >= close[1] and close <= open[1]

is_doji() =>
    body = math.abs(close - open)
    avg_body = ta.sma(math.abs(close - open), 20)
    body <= avg_body * 0.1

// ===============================
// INDICATOR CALCULATIONS
// ===============================
// ATR calculations
atr_val = ta.atr(14)
atr_sl_val = ta.atr(atr_sl_length)
atr_tp_val = ta.atr(atr_tp_length)

// Volume and Volatility
volume_avg = ta.sma(volume, volume_length)
volatility = ta.stdev(close, vol_length) / ta.sma(close, vol_length) * 100

// Parabolic SAR
sar_val = ta.sar(sar_start, sar_increment, sar_maximum)

// RSI
rsi1_val = ta.rsi(close, rsi1_length)

// Moving Averages
ma_fast_val = ma_function(close, ma_fast_length, ma_fast_type)
ma_slow_val = ma_function(close, ma_slow_length, ma_slow_type)

// Channels
[bb_upper, bb_basis, bb_lower] = bollinger_bands(close, channel_length, channel_multiplier)
[kc_upper, kc_basis, kc_lower] = keltner_channel(close, channel_length, channel_multiplier)

channel_upper = channel_type == "Bollinger Bands" ? bb_upper : kc_upper
channel_basis = channel_type == "Bollinger Bands" ? bb_basis : kc_basis
channel_lower = channel_type == "Bollinger Bands" ? bb_lower : kc_lower

// Supertrend
[st_trend, st_val, st_up, st_down] = supertrend(supertrend_factor, supertrend_period)

// RVI
[rvi_val, rvi_signal] = calculate_rvi(rvi_length)

// MFI
mfi_val = ta.mfi(hlc3, mfi_length)

// CCI
cci_val = ta.cci(hlc3, cci_length)

// Momentum
momentum_val = ta.mom(close, momentum_length) / close[momentum_length]

// Dynamic RSI
[drsi_upper, drsi_lower] = dynamic_bands(rsi1_val, drsi_band_length, drsi_band_mult)

// Dynamic MFI
[dmfi_upper, dmfi_lower] = dynamic_bands(mfi_val, dmfi_band_length, dmfi_band_mult)

// SMI Ergodic
[smi_val, smi_signal] = smi_ergodic(smio_short_length, smio_long_length, smio_signal_length)

// DMI
[diplus, diminus, adx] = ta.dmi(dmi_length, dmi_length)

// Chaikin Money Flow
cmf_val = calculate_cmf(chaikin_length)

// Balance of Power
bop_val = calculate_bop()

// MACD
[macd_line, macd_signal, macd_hist] = ta.macd(close, macd_fast_length, macd_slow_length, macd_signal_length)

// QQE
[qqe_rsi, qqe_long, qqe_short, qqe_trend] = calculate_qqe(close, qqe_rsi_length, qqe_smoothing, qqe_factor)

// ===============================
// SIGNAL MEMORY VARIABLES
// ===============================
var int ma_cross_bar = 0
var int macd_cross_bar = 0

// ===============================
// SIGNAL LOGIC
// ===============================
// Date and day filters
date_filter = year >= startYear and year <= stopYear

day_blocked = (blockMo and dayofweek == dayofweek.monday) or (blockTu and dayofweek == dayofweek.tuesday) or (blockWe and dayofweek == dayofweek.wednesday) or (blockTh and dayofweek == dayofweek.thursday) or (blockFr and dayofweek == dayofweek.friday) or (blockSa and dayofweek == dayofweek.saturday) or (blockSu and dayofweek == dayofweek.sunday)

day_filter = not day_blocked

// Initialize counters
indicators_enabled = 0
conditions_met = 0

// Volume filter
volume_condition_result = true
if useVolumeFilter
    indicators_enabled += 1
    if volume_condition == "Above Average"
        volume_condition_result := volume > volume_avg * volume_multiplier
    else if volume_condition == "Below Average"
        volume_condition_result := volume < volume_avg / volume_multiplier
    else if volume_condition == "Rising"
        volume_condition_result := volume > volume[1]
    else if volume_condition == "Falling"
        volume_condition_result := volume < volume[1]
    else
        volume_condition_result := false
    
    if volume_condition_result
        conditions_met += 1

// Volatility filter
volatility_condition_result = true
if useVolatilityFilter
    indicators_enabled += 1
    if vol_condition == "Rising"
        volatility_condition_result := volatility > volatility[1]
    else if vol_condition == "Falling"
        volatility_condition_result := volatility < volatility[1]
    else if vol_condition == "Above Level"
        volatility_condition_result := volatility > vol_threshold
    else if vol_condition == "Below Level"
        volatility_condition_result := volatility < vol_threshold
    else
        volatility_condition_result := false
    
    if volatility_condition_result
        conditions_met += 1

// High/Low Filter
highlow_result = true
if useHighLowFilter
    indicators_enabled += 1
    highest_price = ta.highest(high, highlow_period)
    lowest_price = ta.lowest(low, highlow_period)
    price_change_long = (close - lowest_price) / lowest_price * 100
    price_change_short = (highest_price - close) / highest_price * 100
    
    highlow_result := (useLong and price_change_long >= highlow_min_change) or (useShort and price_change_short >= highlow_min_change)
    if highlow_result
        conditions_met += 1

// ATR Change Filter
atr_change_result = true
if useATRChangeFilter
    indicators_enabled += 1
    current_atr = ta.atr(14)
    past_atr = ta.sma(ta.atr(14), atr_change_period)
    atr_change = (current_atr - past_atr) / past_atr * 100
    
    atr_change_result := atr_change >= atr_change_threshold
    if atr_change_result
        conditions_met += 1

// Block If Worse Filter
block_worse_result = true
if useBlockIfWorse
    indicators_enabled += 1
    price_move = (close - close[1]) / close[1] * 100
    
    block_worse_result := not ((useLong and price_move > blockIfWorsePercent) or (useShort and price_move < -blockIfWorsePercent))
    if block_worse_result
        conditions_met += 1

// PinBar + MA
pinbar_ma_result = false
if usePinBarMA
    indicators_enabled += 1
    ma1 = ta.ema(close, pinbar_ma1_length)
    ma2 = ta.ema(close, pinbar_ma2_length)
    ma3 = ta.ema(close, pinbar_ma3_length)
    
    is_pin = is_hammer()
    ma_aligned_long = ma1 > ma2 and ma2 > ma3
    ma_aligned_short = ma1 < ma2 and ma2 < ma3
    
    pinbar_ma_result := (useLong and is_pin and ma_aligned_long) or (useShort and is_pin and ma_aligned_short)
    if pinbar_ma_result
        conditions_met += 1

// Supertrend Filter
supertrend_result = true
if useSupertrend
    indicators_enabled += 1
    supertrend_result := (useLong and st_trend == 1) or (useShort and st_trend == -1)
    if supertrend_result
        conditions_met += 1

// Consolidation Zone
consolidation_result = true
if useConsolidation
    indicators_enabled += 1
    highest_cons = ta.highest(high, consolidation_length)
    lowest_cons = ta.lowest(low, consolidation_length)
    range_percent = (highest_cons - lowest_cons) / lowest_cons * 100
    
    consolidation_result := range_percent > consolidation_range
    if consolidation_result
        conditions_met += 1

// RSI Condition
rsi1_result = true
if useRSI1
    indicators_enabled += 1
    rsi1_result := (useLong and rsi1_val < rsi1_oversold) or (useShort and rsi1_val > rsi1_overbought)
    if rsi1_result
        conditions_met += 1

// RVI Condition
rvi_result = true
if useRVI
    indicators_enabled += 1
    rvi_result := (useLong and rvi_val < rvi_oversold) or (useShort and rvi_val > rvi_overbought)
    if rvi_result
        conditions_met += 1

// MFI Condition
mfi_result = true
if useMFI
    indicators_enabled += 1
    mfi_result := (useLong and mfi_val < mfi_oversold) or (useShort and mfi_val > mfi_overbought)
    if mfi_result
        conditions_met += 1

// CCI Condition
cci_result = true
if useCCI
    indicators_enabled += 1
    cci_result := (useLong and cci_val < cci_oversold) or (useShort and cci_val > cci_overbought)
    if cci_result
        conditions_met += 1

// Momentum Condition
momentum_result = true
if useMomentum
    indicators_enabled += 1
    momentum_result := (useLong and momentum_val < momentum_oversold) or (useShort and momentum_val > momentum_overbought)
    if momentum_result
        conditions_met += 1

// Dynamic RSI
drsi_result = true
if useDynamicRSI
    indicators_enabled += 1
    drsi_result := (useLong and rsi1_val < drsi_lower) or (useShort and rsi1_val > drsi_upper)
    if drsi_result
        conditions_met += 1

// Dynamic MFI
dmfi_result = true
if useDynamicMFI
    indicators_enabled += 1
    dmfi_result := (useLong and mfi_val < dmfi_lower) or (useShort and mfi_val > dmfi_upper)
    if dmfi_result
        conditions_met += 1

// SMI Ergodic
smi_result = true
if useSMIO
    indicators_enabled += 1
    smi_result := (useLong and smi_val < smio_oversold) or (useShort and smi_val > smio_overbought)
    if smi_result
        conditions_met += 1

// DMI Condition
dmi_result = true
if useDMI
    indicators_enabled += 1
    di_cross_long = ta.crossover(diplus, diminus)
    di_cross_short = ta.crossunder(diplus, diminus)
    adx_strong = adx > dmi_adx_threshold
    
    if dmi_signal_type == "DI Cross"
        dmi_result := (useLong and di_cross_long) or (useShort and di_cross_short)
    else if dmi_signal_type == "ADX Level"
        dmi_result := adx_strong
    else if dmi_signal_type == "Both"
        dmi_result := ((useLong and di_cross_long) or (useShort and di_cross_short)) and adx_strong
    else
        dmi_result := false
    
    if dmi_result
        conditions_met += 1

// Chaikin Money Flow
chaikin_result = true
if useChaikin
    indicators_enabled += 1
    cmf_ob_os = (useLong and cmf_val < chaikin_oversold) or (useShort and cmf_val > chaikin_overbought)
    cmf_zero = chaikin_use_zero and ((useLong and ta.crossover(cmf_val, 0)) or (useShort and ta.crossunder(cmf_val, 0)))
    
    chaikin_result := cmf_ob_os or cmf_zero
    if chaikin_result
        conditions_met += 1

// Balance of Power
bop_result = true
if useBOP
    indicators_enabled += 1
    bop_ob_os = (useLong and bop_val < bop_oversold) or (useShort and bop_val > bop_overbought)
    bop_zero = bop_use_zero and ((useLong and ta.crossover(bop_val, 0)) or (useShort and ta.crossunder(bop_val, 0)))
    
    bop_result := bop_ob_os or bop_zero
    if bop_result
        conditions_met += 1

// MACD Condition with Signal Memory
macd_result = false
if useMACD
    indicators_enabled += 1
    signal_cross_long = ta.crossover(macd_line, macd_signal)
    signal_cross_short = ta.crossunder(macd_line, macd_signal)
    zero_cross_long = ta.crossover(macd_line, 0)
    zero_cross_short = ta.crossunder(macd_line, 0)
    
    current_macd_signal = false
    if macd_signal_type == "Signal Cross"
        current_macd_signal := (useLong and signal_cross_long) or (useShort and signal_cross_short)
    else if macd_signal_type == "Zero Cross"
        current_macd_signal := (useLong and zero_cross_long) or (useShort and zero_cross_short)
    else if macd_signal_type == "Both"
        current_macd_signal := ((useLong and signal_cross_long) or (useShort and signal_cross_short)) or ((useLong and zero_cross_long) or (useShort and zero_cross_short))
    
    if current_macd_signal
        macd_cross_bar := bar_index
    
    if macd_signal_memory and bar_index - macd_cross_bar <= macd_memory_bars
        macd_result := true
    else
        macd_result := current_macd_signal
    
    if macd_result
        conditions_met += 1

// QQE Signals
qqe_result = true
if useQQE
    indicators_enabled += 1
    qqe_long_signal = qqe_trend == 1 and qqe_trend[1] != 1
    qqe_short_signal = qqe_trend == -1 and qqe_trend[1] != -1
    
    qqe_result := (useLong and qqe_long_signal) or (useShort and qqe_short_signal)
    if qqe_result
        conditions_met += 1

// Divergence Detection (fixed - not using var)
divergence_result = false
if useDivergence
    indicators_enabled += 1
    
    // Simple divergence check
    lookback = 5
    
    // Check for bullish divergence (price lower low, indicator higher low)
    price_lower_low = low < ta.lowest(low[1], lookback)
    rsi_higher_low = rsi1_val > ta.lowest(rsi1_val[1], lookback)
    bull_div = price_lower_low and rsi_higher_low
    
    // Check for bearish divergence (price higher high, indicator lower high)
    price_higher_high = high > ta.highest(high[1], lookback)
    rsi_lower_high = rsi1_val < ta.highest(rsi1_val[1], lookback)
    bear_div = price_higher_high and rsi_lower_high
    
    divergence_result := (useLong and bull_div) or (useShort and bear_div)
    if divergence_result
        conditions_met += 1

// Candle Patterns
candle_result = false
if useCandlePatterns
    indicators_enabled += 1
    
    bull_patterns = (use_hammer and is_hammer() and close > open) or (use_engulfing and is_bullish_engulfing()) or (use_doji and is_doji() and close > ta.sma(close, 20))
    
    bear_patterns = (use_hammer and is_hammer() and close < open) or (use_engulfing and is_bearish_engulfing()) or (use_doji and is_doji() and close < ta.sma(close, 20))
    
    candle_result := (useLong and bull_patterns) or (useShort and bear_patterns)
    if candle_result
        conditions_met += 1

// Moving Average Conditions with Signal Memory
ma_signal_current = false
if useMA
    indicators_enabled += 1
    ma_cross_long = ta.crossover(ma_fast_val, ma_slow_val)
    ma_cross_short = ta.crossunder(ma_fast_val, ma_slow_val)
    ma_dir_long = ma_fast_val > ma_fast_val[1] and ma_slow_val > ma_slow_val[1]
    ma_dir_short = ma_fast_val < ma_fast_val[1] and ma_slow_val < ma_slow_val[1]
    ma_same_dir = (ma_fast_val > ma_slow_val and ma_dir_long) or (ma_fast_val < ma_slow_val and ma_dir_short)
    
    current_ma_signal = false
    if ma_signal_type == "Cross"
        current_ma_signal := (useLong and ma_cross_long) or (useShort and ma_cross_short)
    else if ma_signal_type == "Direction"
        current_ma_signal := (useLong and ma_dir_long) or (useShort and ma_dir_short)
    else if ma_signal_type == "Both Direction Same"
        current_ma_signal := (useLong and ma_same_dir and ma_fast_val > ma_slow_val) or (useShort and ma_same_dir and ma_fast_val < ma_slow_val)
    
    if current_ma_signal
        ma_cross_bar := bar_index
    
    if ma_signal_memory and bar_index - ma_cross_bar <= ma_memory_bars
        ma_signal_current := true
    else
        ma_signal_current := current_ma_signal
    
    if ma_signal_current
        conditions_met += 1

// Channels Conditions
channels_result = false
if useChannels
    indicators_enabled += 1
    
    touch_long = low <= channel_lower and close > channel_lower
    touch_short = high >= channel_upper and close < channel_upper
    
    close_outside_long = close[1] < channel_lower and close > channel_lower
    close_outside_short = close[1] > channel_upper and close < channel_upper
    
    breakout_long = close > channel_upper
    breakout_short = close < channel_lower
    
    if channel_signal_type == "Touch"
        channels_result := (useLong and touch_long) or (useShort and touch_short)
    else if channel_signal_type == "Close Outside"
        channels_result := (useLong and close_outside_long) or (useShort and close_outside_short)
    else if channel_signal_type == "Breakout"
        channels_result := (useLong and breakout_long) or (useShort and breakout_short)
    
    if channels_result
        conditions_met += 1

// External Indicator
external_result = true
if useExternal
    indicators_enabled += 1
    
    if external_condition == "Above"
        external_result := external_source > external_level
    else if external_condition == "Below"
        external_result := external_source < external_level
    else if external_condition == "Cross Up"
        external_result := ta.crossover(external_source, external_level)
    else if external_condition == "Cross Down"
        external_result := ta.crossunder(external_source, external_level)
    else
        external_result := false
    
    if external_result
        conditions_met += 1

// Linear Regression Channel
lrc_result = true
if useLRC
    indicators_enabled += 1
    lrc_basis = ta.linreg(close, lrc_length, 0)
    lrc_dev = ta.stdev(close, lrc_length)
    lrc_upper = lrc_basis + lrc_deviation * lrc_dev
    lrc_lower = lrc_basis - lrc_deviation * lrc_dev
    
    lrc_result := (useLong and close < lrc_lower) or (useShort and close > lrc_upper)
    if lrc_result
        conditions_met += 1

// ===============================
// FINAL SIGNAL CONDITIONS
// ===============================
// Basic conditions check
basic_conditions = date_filter and day_filter

// Check if all enabled indicators are met
all_indicators_met = indicators_enabled == 0 or conditions_met == indicators_enabled

// Direction setup
long_direction = enableDCA ? gridDirection == "Long" : useLong
short_direction = enableDCA ? gridDirection == "Short" : useShort

// Final signals - only when position is 0 and on bar close
long_signal = long_direction and all_indicators_met and basic_conditions and strategy.position_size == 0 and barstate.isconfirmed
short_signal = short_direction and all_indicators_met and basic_conditions and strategy.position_size == 0 and barstate.isconfirmed

// ===============================
// DCA GRID VARIABLES
// ===============================
var float entry_price = na
var int order_count = 0
var float grid_step = na
var array<float> dca_levels = array.new<float>()
var array<bool> dca_order_placed = array.new<bool>()
var float total_position_size = 0.0
var float weighted_avg_price = 0.0
var float trailing_stop_level = na
var bool breakeven_activated = false
var bool position_closed = false

// DCA Functions
reset_dca_tracking() =>
    array.clear(dca_order_placed)
    for i = 0 to numberOfOrders - 1
        array.push(dca_order_placed, false)

get_position_size(order_index) =>
    base_size = depositForBot / numberOfOrders
    martingale_size = base_size * math.pow(martingaleMultiplier, order_index - 1)
    martingale_size * leverage

// Initialize DCA Grid
if enableDCA and (long_signal or short_signal) and na(entry_price)
    entry_price := close
    order_count := 1
    grid_step := entry_price * gridSizePercent / 100
    
    array.clear(dca_levels)
    array.push(dca_levels, entry_price)
    
    reset_dca_tracking()
    array.set(dca_order_placed, 0, true)
    
    for i = 1 to numberOfOrders - 1
        step_multiplier = math.pow(logarithmicSteps, i - 1)
        level_distance = grid_step * step_multiplier * i
        level = gridDirection == "Long" ? entry_price - level_distance : entry_price + level_distance
        array.push(dca_levels, level)

// Check for big drawdown
check_big_drawdown = closeOnBigDrawdown and strategy.position_size != 0 and strategy.openprofit <= drawdownToClose

if check_big_drawdown
    strategy.close_all(comment="Big Drawdown")
    entry_price := na
    order_count := 0
    total_position_size := 0.0
    weighted_avg_price := 0.0
    trailing_stop_level := na
    breakeven_activated := false
    position_closed := true

// ===============================
// STRATEGY EXECUTION
// ===============================
// Order Indent Logic
var float indent_price = na
var int indent_bar_count = 0

if useOrderIndent and (long_signal or short_signal) and strategy.position_size == 0
    indent_direction = long_signal ? -1 : 1
    indent_price := close * (1 + indent_direction * indentPercent / 100)
    indent_bar_count := 0

if not na(indent_price)
    indent_bar_count += 1
    if indent_bar_count > indentCancelBars
        indent_price := na
        indent_bar_count := 0

// Execute Orders
if enableDCA
    // Entry with indent
    entry_condition_long = gridDirection == "Long" and strategy.position_size == 0 and (useOrderIndent ? not na(indent_price) and close <= indent_price : long_signal)
    
    entry_condition_short = gridDirection == "Short" and strategy.position_size == 0 and (useOrderIndent ? not na(indent_price) and close >= indent_price : short_signal)
    
    if entry_condition_long
        qty = get_position_size(1) / close
        strategy.entry("DCA_L1", strategy.long, qty=qty)
        total_position_size := qty
        weighted_avg_price := close
        indent_price := na
        indent_bar_count := 0
        position_closed := false
    
    if entry_condition_short
        qty = get_position_size(1) / close
        strategy.entry("DCA_S1", strategy.short, qty=qty)
        total_position_size := qty
        weighted_avg_price := close
        indent_price := na
        indent_bar_count := 0
        position_closed := false
    
    // DCA Orders
    if not na(entry_price) and order_count < numberOfOrders and not position_closed
        if gridDirection == "Long" and strategy.position_size > 0
            for i = order_count to numberOfOrders - 1
                if not array.get(dca_order_placed, i)
                    next_level = array.get(dca_levels, i)
                    if close <= next_level
                        order_count += 1
                        qty = get_position_size(order_count) / close
                        strategy.entry("DCA_L" + str.tostring(order_count), strategy.long, qty=qty)
                        array.set(dca_order_placed, i, true)
                        
                        total_position_size := total_position_size + qty
                        weighted_avg_price := (weighted_avg_price * (total_position_size - qty) + close * qty) / total_position_size
                        break
        
        if gridDirection == "Short" and strategy.position_size < 0
            for i = order_count to numberOfOrders - 1
                if not array.get(dca_order_placed, i)
                    next_level = array.get(dca_levels, i)
                    if close >= next_level
                        order_count += 1
                        qty = get_position_size(order_count) / close
                        strategy.entry("DCA_S" + str.tostring(order_count), strategy.short, qty=qty)
                        array.set(dca_order_placed, i, true)
                        
                        total_position_size := total_position_size + qty
                        weighted_avg_price := (weighted_avg_price * (total_position_size - qty) + close * qty) / total_position_size
                        break

else
    // Simple Long/Short without DCA
    if long_signal and strategy.position_size == 0
        if useOrderIndent
            indent_price := close * (1 - indentPercent / 100)
            indent_bar_count := 0
        else
            strategy.entry("Long", strategy.long)
            position_closed := false
    
    if short_signal and strategy.position_size == 0
        if useOrderIndent
            indent_price := close * (1 + indentPercent / 100)
            indent_bar_count := 0
        else
            strategy.entry("Short", strategy.short)
            position_closed := false
    
    // Execute indent orders
    if not enableDCA and not na(indent_price) and strategy.position_size == 0
        if long_signal and close <= indent_price
            strategy.entry("Long", strategy.long)
            indent_price := na
            indent_bar_count := 0
            position_closed := false
        
        if short_signal and close >= indent_price
            strategy.entry("Short", strategy.short)
            indent_price := na
            indent_bar_count := 0
            position_closed := false

// ===============================
// EXIT MANAGEMENT
// ===============================
// Calculate TP/SL levels
tp_percent = changeTakeProfit and order_count >= ifOrdersMoreThan ? newTakeProfitPercent : takeProfitPercent
sl_percent = slEqualsTp ? tp_percent : stopLossPercent

avg_price = enableDCA and not na(weighted_avg_price) ? weighted_avg_price : strategy.position_avg_price

// Breakeven Logic
if useBreakeven and strategy.position_size != 0 and not breakeven_activated
    profit_percent = 0.0
    if strategy.position_size > 0
        profit_percent := (close - avg_price) / avg_price * 100
    else
        profit_percent := (avg_price - close) / avg_price * 100
    
    if profit_percent >= breakevenActivation
        breakeven_activated := true

// Trailing Stop Logic
if useTrailingStop and strategy.position_size != 0
    profit_percent = 0.0
    if strategy.position_size > 0
        profit_percent := (close - avg_price) / avg_price * 100
    else
        profit_percent := (avg_price - close) / avg_price * 100
    
    if profit_percent >= trailingActivation
        if strategy.position_size > 0
            new_trailing_level = close * (1 - trailingDistance / 100)
            trailing_stop_level := na(trailing_stop_level) ? new_trailing_level : math.max(trailing_stop_level, new_trailing_level)
        else
            new_trailing_level = close * (1 + trailingDistance / 100)
            trailing_stop_level := na(trailing_stop_level) ? new_trailing_level : math.min(trailing_stop_level, new_trailing_level)

// ATR based TP/SL
if (useATRStopLoss or useATRTakeProfit) and strategy.position_size != 0
    if strategy.position_size > 0
        atr_tp = useATRTakeProfit ? avg_price + atr_tp_val * atr_tp_multiplier : avg_price * (1 + tp_percent / 100)
        atr_sl = useATRStopLoss ? avg_price - atr_sl_val * atr_sl_multiplier : avg_price * (1 - sl_percent / 100)
        
        // Apply breakeven
        if breakeven_activated
            atr_sl := math.max(atr_sl, avg_price * (1 + breakevenLevel / 100))
        
        // Apply trailing stop
        if useTrailingStop and not na(trailing_stop_level)
            atr_sl := math.max(atr_sl, trailing_stop_level)
        
        strategy.exit("Exit L", limit=atr_tp, stop=atr_sl)
    
    if strategy.position_size < 0
        atr_tp = useATRTakeProfit ? avg_price - atr_tp_val * atr_tp_multiplier : avg_price * (1 - tp_percent / 100)
        atr_sl = useATRStopLoss ? avg_price + atr_sl_val * atr_sl_multiplier : avg_price * (1 + sl_percent / 100)
        
        // Apply breakeven
        if breakeven_activated
            atr_sl := math.min(atr_sl, avg_price * (1 - breakevenLevel / 100))
        
        // Apply trailing stop
        if useTrailingStop and not na(trailing_stop_level)
            atr_sl := math.min(atr_sl, trailing_stop_level)
        
        strategy.exit("Exit S", limit=atr_tp, stop=atr_sl)

// Static TP/SL
else if close_static_tp_sl and strategy.position_size != 0
    if strategy.position_size > 0
        tp_level = avg_price * (1 + tp_percent / 100)
        sl_level = avg_price * (1 - sl_percent / 100)
        
        // Apply breakeven
        if breakeven_activated
            sl_level := math.max(sl_level, avg_price * (1 + breakevenLevel / 100))
        
        // Apply trailing stop
        if useTrailingStop and not na(trailing_stop_level)
            sl_level := math.max(sl_level, trailing_stop_level)
        
        // Multi TP Logic
        if useMultiTP
            tp1_price = avg_price * (1 + tp1_percent / 100)
            tp2_price = avg_price * (1 + tp2_percent / 100)
            tp3_price = avg_price * (1 + tp3_percent / 100)
            tp4_price = avg_price * (1 + tp4_percent / 100)
            
            strategy.exit("TP1 L", qty_percent=tp1_qty, limit=tp1_price, stop=sl_level)
            strategy.exit("TP2 L", qty_percent=tp2_qty, limit=tp2_price, stop=sl_level)
            strategy.exit("TP3 L", qty_percent=tp3_qty, limit=tp3_price, stop=sl_level)
            strategy.exit("TP4 L", qty_percent=100, limit=tp4_price, stop=sl_level)
        else
            strategy.exit("Exit L", limit=tp_level, stop=sl_level)

    if strategy.position_size < 0
        tp_level = avg_price * (1 - tp_percent / 100)
        sl_level = avg_price * (1 + sl_percent / 100)
        
        // Apply breakeven
        if breakeven_activated
            sl_level := math.min(sl_level, avg_price * (1 - breakevenLevel / 100))
        
        // Apply trailing stop
        if useTrailingStop and not na(trailing_stop_level)
            sl_level := math.min(sl_level, trailing_stop_level)
        
        // Multi TP Logic
        if useMultiTP
            tp1_price = avg_price * (1 - tp1_percent / 100)
            tp2_price = avg_price * (1 - tp2_percent / 100)
            tp3_price = avg_price * (1 - tp3_percent / 100)
            tp4_price = avg_price * (1 - tp4_percent / 100)
            
            strategy.exit("TP1 S", qty_percent=tp1_qty, limit=tp1_price, stop=sl_level)
            strategy.exit("TP2 S", qty_percent=tp2_qty, limit=tp2_price, stop=sl_level)
            strategy.exit("TP3 S", qty_percent=tp3_qty, limit=tp3_price, stop=sl_level)
            strategy.exit("TP4 S", qty_percent=100, limit=tp4_price, stop=sl_level)
        else
            strategy.exit("Exit S", limit=tp_level, stop=sl_level)

// ===============================
// CLOSE SIGNALS
// ===============================
// Parabolic SAR Close
if close_parabolic_sar and strategy.position_size != 0
    sar_close = (strategy.position_size > 0 and close < sar_val) or (strategy.position_size < 0 and close > sar_val)
    if sar_close and (not closeOnlyInProfit or strategy.openprofit > 0)
        strategy.close_all(comment="SAR Close")
        position_closed := true


// Channel Close
if close_bb_kc and strategy.position_size != 0 and useChannels
    channel_close = (strategy.position_size > 0 and close > channel_upper) or (strategy.position_size < 0 and close < channel_lower)
    if channel_close and (not closeOnlyInProfit or strategy.openprofit > 0)
        strategy.close_all(comment="Channel Close")
        position_closed := true

// QQE Close
if close_qqe and strategy.position_size != 0 and useQQE
    qqe_close = (strategy.position_size > 0 and qqe_trend == -1) or (strategy.position_size < 0 and qqe_trend == 1)
    if qqe_close and (not closeOnlyInProfit or strategy.openprofit > 0)
        strategy.close_all(comment="QQE Close")
        position_closed := true

// RSI Close
if close_rsi and strategy.position_size != 0 and useRSI1
    rsi_close = (strategy.position_size > 0 and rsi1_val > rsi1_overbought) or (strategy.position_size < 0 and rsi1_val < rsi1_oversold)
    if rsi_close and (not closeOnlyInProfit or strategy.openprofit > 0)
        strategy.close_all(comment="RSI Close")
        position_closed := true

// MA Cross Close - Fixed for Pine Script v5
// Вычисляем кроссы всегда (требование Pine Script v5)
ma_cross_under = ta.crossunder(ma_fast_val, ma_slow_val)
ma_cross_over = ta.crossover(ma_fast_val, ma_slow_val)

// MA Cross Close - логика срабатывает только при нужных условиях
if close_ma_cross and strategy.position_size != 0 and useMA
    ma_close = (strategy.position_size > 0 and ma_cross_under) or (strategy.position_size < 0 and ma_cross_over)
    if ma_close and (not closeOnlyInProfit or strategy.openprofit > 0)
        strategy.close_all(comment="MA Close")
        position_closed := true

// Pyramiding Logic
if usePyramiding and strategy.position_size != 0 and not position_closed
    price_move = 0.0
    if strategy.position_size > 0
        price_move := (close - avg_price) / avg_price * 100
    else
        price_move := (avg_price - close) / avg_price * 100
    
    if price_move >= pyramidMinMove
        if strategy.position_size > 0 and all_indicators_met and basic_conditions
            strategy.entry("Pyramid L", strategy.long)
        if strategy.position_size < 0 and all_indicators_met and basic_conditions
            strategy.entry("Pyramid S", strategy.short)

// Reverse Orders on SL
if useReverseOrderOnSL and strategy.closedtrades > 0
    last_trade = strategy.closedtrades - 1
    last_profit = strategy.closedtrades.profit(last_trade)
    
    if last_profit < 0 and barstate.isconfirmed
        if strategy.closedtrades.size(last_trade) > 0
            strategy.entry("Rev S", strategy.short)
        else
            strategy.entry("Rev L", strategy.long)

// Reset variables when position closes
if strategy.position_size == 0
    if not na(entry_price)
        entry_price := na
        order_count := 0
        total_position_size := 0.0
        weighted_avg_price := 0.0
        trailing_stop_level := na
        breakeven_activated := false
    position_closed := false

// ===============================
// VISUALIZATION
// ===============================
// DCA Grid Visualization
if enableDCA and not na(entry_price) and showTPSL and barstate.islast
    for i = 0 to array.size(dca_levels) - 1
        if i < numberOfOrders
            level = array.get(dca_levels, i)
            is_placed = i < order_count
            line.new(bar_index - 10, level, bar_index + 10, level, 
                     color=is_placed ? color.green : color.orange, 
                     style=is_placed ? line.style_solid : line.style_dashed, 
                     width=1)

// TP/SL Visualization
if showTPSL and strategy.position_size != 0 and barstate.islast
    current_tp_percent = changeTakeProfit and order_count >= ifOrdersMoreThan ? newTakeProfitPercent : takeProfitPercent
    current_sl_percent = slEqualsTp ? current_tp_percent : stopLossPercent
    
    if strategy.position_size > 0
        tp_viz = avg_price * (1 + current_tp_percent / 100)
        sl_viz = avg_price * (1 - current_sl_percent / 100)
        
        if breakeven_activated
            sl_viz := math.max(sl_viz, avg_price * (1 + breakevenLevel / 100))
        
        if useTrailingStop and not na(trailing_stop_level)
            sl_viz := math.max(sl_viz, trailing_stop_level)
        
        line.new(bar_index, tp_viz, bar_index + 5, tp_viz, color=color.green, width=2)
        line.new(bar_index, sl_viz, bar_index + 5, sl_viz, color=color.red, width=2)
        
        // Multi TP visualization
        if useMultiTP
            tp1_viz = avg_price * (1 + tp1_percent / 100)
            tp2_viz = avg_price * (1 + tp2_percent / 100)
            tp3_viz = avg_price * (1 + tp3_percent / 100)
            tp4_viz = avg_price * (1 + tp4_percent / 100)
            
            line.new(bar_index, tp1_viz, bar_index + 3, tp1_viz, color=color.lime, width=1, style=line.style_dashed)
            line.new(bar_index, tp2_viz, bar_index + 3, tp2_viz, color=color.lime, width=1, style=line.style_dashed)
            line.new(bar_index, tp3_viz, bar_index + 3, tp3_viz, color=color.lime, width=1, style=line.style_dashed)
            line.new(bar_index, tp4_viz, bar_index + 3, tp4_viz, color=color.lime, width=1, style=line.style_dashed)
    
    if strategy.position_size < 0
        tp_viz = avg_price * (1 - current_tp_percent / 100)
        sl_viz = avg_price * (1 + current_sl_percent / 100)
        
        if breakeven_activated
            sl_viz := math.min(sl_viz, avg_price * (1 - breakevenLevel / 100))
        
        if useTrailingStop and not na(trailing_stop_level)
            sl_viz := math.min(sl_viz, trailing_stop_level)
        
        line.new(bar_index, tp_viz, bar_index + 5, tp_viz, color=color.green, width=2)
        line.new(bar_index, sl_viz, bar_index + 5, sl_viz, color=color.red, width=2)

// Signal Visualization
if showSignals
    if long_signal
        label.new(bar_index, low - atr_val, "LONG", 
                  color=color.green, style=label.style_label_up, textcolor=color.white, size=size.normal)
    
    if short_signal
        label.new(bar_index, high + atr_val, "SHORT", 
                  color=color.red, style=label.style_label_down, textcolor=color.white, size=size.normal)

// Trailing Stop Activation Visualization
if visualizeTrailingActivation and strategy.position_size != 0 and barstate.islast
    activation_level = 0.0
    if strategy.position_size > 0
        activation_level := avg_price * (1 + trailingActivation / 100)
    else
        activation_level := avg_price * (1 - trailingActivation / 100)
    line.new(bar_index, activation_level, bar_index + 5, activation_level, color=color.purple, width=1, style=line.style_dotted)

// Plot indicators
plot(useMA ? ma_fast_val : na, "Fast MA", color=color.blue, linewidth=1)
plot(useMA ? ma_slow_val : na, "Slow MA", color=color.red, linewidth=1)

plot(useChannels ? channel_upper : na, "Channel Upper", color=color.purple)
plot(useChannels ? channel_basis : na, "Channel Basis", color=color.gray)
plot(useChannels ? channel_lower : na, "Channel Lower", color=color.purple)

plot(useSupertrend ? st_val : na, "Supertrend", color=st_trend == 1 ? color.green : color.red, linewidth=2)

plotshape(close_parabolic_sar ? sar_val : na, style=shape.circle, location=location.absolute, color=close > sar_val ? color.green : color.red, size=size.tiny)

// ===============================
// ALERTS
// ===============================
// Entry alerts
if long_signal
    if enableDCA and sendAlertFirstOrder
        alert_msg = '{"action": "LONG", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(close) + ', "grid": ' + str.tostring(gridSizePercent) + ', "orders": ' + str.tostring(numberOfOrders) + '}'
        alert(alert_msg, alert.freq_once_per_bar)
    else if not enableDCA
        alert_msg = '{"action": "LONG", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(close) + '}'
        alert(alert_msg, alert.freq_once_per_bar)

if short_signal
    if enableDCA and sendAlertFirstOrder
        alert_msg = '{"action": "SHORT", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(close) + ', "grid": ' + str.tostring(gridSizePercent) + ', "orders": ' + str.tostring(numberOfOrders) + '}'
        alert(alert_msg, alert.freq_once_per_bar)
    else if not enableDCA
        alert_msg = '{"action": "SHORT", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(close) + '}'
        alert(alert_msg, alert.freq_once_per_bar)

// Exit alerts
if strategy.position_size[1] != 0 and strategy.position_size == 0
    alert_msg = '{"action": "CLOSE", "symbol": "' + syminfo.ticker + '", "price": ' + str.tostring(close) + '}'
    alert(alert_msg, alert.freq_once_per_bar)

// ===============================
// INFORMATION TABLES
// ===============================
// DCA Info Table
if enableDCA
    var table info_table = table.new(position.top_right, 2, 10, bgcolor=color.new(color.black, 90), border_width=1)
    
    if barstate.islast
        table.cell(info_table, 0, 0, "DCA Grid Info", bgcolor=color.blue, text_color=color.white)
        table.cell(info_table, 1, 0, "", bgcolor=color.blue)
        
        table.cell(info_table, 0, 1, "Direction:", text_color=color.white)
        table.cell(info_table, 1, 1, gridDirection, text_color=color.white)
        
        table.cell(info_table, 0, 2, "Grid Size:", text_color=color.white)
        table.cell(info_table, 1, 2, str.tostring(gridSizePercent) + "%", text_color=color.white)
        
        table.cell(info_table, 0, 3, "Orders:", text_color=color.white)
        table.cell(info_table, 1, 3, str.tostring(numberOfOrders), text_color=color.white)
        
        table.cell(info_table, 0, 4, "Martingale:", text_color=color.white)
        table.cell(info_table, 1, 4, str.tostring(martingaleMultiplier), text_color=color.white)
        
        table.cell(info_table, 0, 5, "Current Orders:", text_color=color.white)
        table.cell(info_table, 1, 5, str.tostring(order_count), text_color=color.white)
        
        table.cell(info_table, 0, 6, "Entry Price:", text_color=color.white)
        table.cell(info_table, 1, 6, na(entry_price) ? "N/A" : str.tostring(entry_price, "#.####"), text_color=color.white)
        
        table.cell(info_table, 0, 7, "Avg Price:", text_color=color.white)
        table.cell(info_table, 1, 7, na(avg_price) ? "N/A" : str.tostring(avg_price, "#.####"), text_color=color.white)
        
        table.cell(info_table, 0, 8, "Position:", text_color=color.white)
        table.cell(info_table, 1, 8, str.tostring(strategy.position_size, "#.####"), text_color=color.white)
        
        table.cell(info_table, 0, 9, "P&L:", text_color=color.white)
        table.cell(info_table, 1, 9, str.tostring(strategy.openprofit, "#.##") + "$", 
                  text_color=strategy.openprofit >= 0 ? color.green : color.red)

// Performance Table
var table perf_table = table.new(position.bottom_right, 2, 7, bgcolor=color.new(color.black, 90), border_width=1)

if barstate.islast
    table.cell(perf_table, 0, 0, "Performance", bgcolor=color.blue, text_color=color.white)
    table.cell(perf_table, 1, 0, "", bgcolor=color.blue)
    
    table.cell(perf_table, 0, 1, "Total Trades:", text_color=color.white)
    table.cell(perf_table, 1, 1, str.tostring(strategy.closedtrades), text_color=color.white)
    
    table.cell(perf_table, 0, 2, "Win Rate:", text_color=color.white)
    win_rate = strategy.closedtrades > 0 ? strategy.wintrades / strategy.closedtrades * 100 : 0
    table.cell(perf_table, 1, 2, str.tostring(win_rate, "#.##") + "%", text_color=color.white)
    
    table.cell(perf_table, 0, 3, "Profit Factor:", text_color=color.white)
    profit_factor = strategy.grossloss != 0 ? math.abs(strategy.grossprofit / strategy.grossloss) : 0
    table.cell(perf_table, 1, 3, str.tostring(profit_factor, "#.##"), text_color=color.white)
    
    table.cell(perf_table, 0, 4, "Net Profit:", text_color=color.white)
    table.cell(perf_table, 1, 4, str.tostring(strategy.netprofit, "#.##") + "$", 
              text_color=strategy.netprofit >= 0 ? color.green : color.red)
    
    table.cell(perf_table, 0, 5, "Max DD:", text_color=color.white)
    table.cell(perf_table, 1, 5, str.tostring(strategy.max_drawdown, "#.##") + "$", text_color=color.white)
    
    table.cell(perf_table, 0, 6, "Max DD %:", text_color=color.white)
    max_dd_percent = strategy.initial_capital > 0 ? strategy.max_drawdown / strategy.initial_capital * 100 : 0
    table.cell(perf_table, 1, 6, str.tostring(max_dd_percent, "#.##") + "%", text_color=color.white)

// Active Indicators Table
var table indicators_table = table.new(position.bottom_left, 2, 20, bgcolor=color.new(color.black, 90), border_width=1)

if barstate.islast and showSignals
    table.cell(indicators_table, 0, 0, "Active Indicators", bgcolor=color.green, text_color=color.white)
    table.cell(indicators_table, 1, 0, "", bgcolor=color.green)
    
    row = 1
    
    // Show active indicators
    if useVolumeFilter
        table.cell(indicators_table, 0, row, "Volume:", text_color=color.white)
        table.cell(indicators_table, 1, row, volume_condition_result ? "✓" : "✗", 
                  text_color=volume_condition_result ? color.green : color.red)
        row += 1
    
    if useVolatilityFilter
        table.cell(indicators_table, 0, row, "Volatility:", text_color=color.white)
        table.cell(indicators_table, 1, row, volatility_condition_result ? "✓" : "✗", 
                  text_color=volatility_condition_result ? color.green : color.red)
        row += 1
    
    if useRSI1
        table.cell(indicators_table, 0, row, "RSI:", text_color=color.white)
        table.cell(indicators_table, 1, row, str.tostring(rsi1_val, "#.#"), text_color=color.white)
        row += 1
    
    if useMA
        table.cell(indicators_table, 0, row, "MA:", text_color=color.white)
        table.cell(indicators_table, 1, row, ma_signal_current ? "✓" : "✗", 
                  text_color=ma_signal_current ? color.green : color.red)
        row += 1
    
    if useChannels
        table.cell(indicators_table, 0, row, "Channel:", text_color=color.white)
        table.cell(indicators_table, 1, row, channels_result ? "✓" : "✗", 
                  text_color=channels_result ? color.green : color.red)
        row += 1
    
    if useSupertrend
        table.cell(indicators_table, 0, row, "Supertrend:", text_color=color.white)
        table.cell(indicators_table, 1, row, st_trend == 1 ? "Bull" : "Bear", 
                  text_color=st_trend == 1 ? color.green : color.red)
        row += 1
    
    if useQQE
        table.cell(indicators_table, 0, row, "QQE:", text_color=color.white)
        qe_color = color.gray
        qe_text = "Neutral"
        if qqe_trend == 1
            qe_color := color.green
            qe_text := "Bull"
        else if qqe_trend == -1
            qe_color := color.red
            qe_text := "Bear"
        table.cell(indicators_table, 1, row, qe_text, text_color=qe_color)
        row += 1
    
    if useMACD
        table.cell(indicators_table, 0, row, "MACD:", text_color=color.white)
        table.cell(indicators_table, 1, row, macd_result ? "✓" : "✗", 
                  text_color=macd_result ? color.green : color.red)
        row += 1
    
    // Summary
    table.cell(indicators_table, 0, row + 1, "Total Active:", text_color=color.white)
    table.cell(indicators_table, 1, row + 1, str.tostring(indicators_enabled), text_color=color.white)
    
    table.cell(indicators_table, 0, row + 2, "Met:", text_color=color.white)
    met_color = color.red
    if conditions_met == indicators_enabled and indicators_enabled > 0
        met_color := color.green
    table.cell(indicators_table, 1, row + 2, str.tostring(conditions_met) + "/" + str.tostring(indicators_enabled), text_color=met_color)

// ===============================
// CSV EXPORT/IMPORT
// ===============================
// Generate CSV export string
if export_button and barstate.islast
    csv_str = ""
    // Basic settings
    csv_str += "showTPSL," + str.tostring(showTPSL ? 1 : 0) + "\n"
    csv_str += "showSignals," + str.tostring(showSignals ? 1 : 0) + "\n"
    csv_str += "startYear," + str.tostring(startYear) + "\n"
    csv_str += "stopYear," + str.tostring(stopYear) + "\n"
    csv_str += "enableDCA," + str.tostring(enableDCA ? 1 : 0) + "\n"
    csv_str += "gridDirection," + gridDirection + "\n"
    csv_str += "depositForBot," + str.tostring(depositForBot) + "\n"
    csv_str += "leverage," + str.tostring(leverage) + "\n"
    csv_str += "gridSizePercent," + str.tostring(gridSizePercent) + "\n"
    csv_str += "numberOfOrders," + str.tostring(numberOfOrders) + "\n"
    csv_str += "martingaleMultiplier," + str.tostring(martingaleMultiplier) + "\n"
    csv_str += "useLong," + str.tostring(useLong ? 1 : 0) + "\n"
    csv_str += "useShort," + str.tostring(useShort ? 1 : 0) + "\n"
    csv_str += "takeProfitPercent," + str.tostring(takeProfitPercent) + "\n"
    csv_str += "stopLossPercent," + str.tostring(stopLossPercent) + "\n"
    csv_str += "useBreakeven," + str.tostring(useBreakeven ? 1 : 0) + "\n"
    csv_str += "breakevenActivation," + str.tostring(breakevenActivation) + "\n"
    csv_str += "useTrailingStop," + str.tostring(useTrailingStop ? 1 : 0) + "\n"
    csv_str += "trailingActivation," + str.tostring(trailingActivation) + "\n"
    csv_str += "trailingDistance," + str.tostring(trailingDistance) + "\n"
    
    // Indicators
    csv_str += "useRSI1," + str.tostring(useRSI1 ? 1 : 0) + "\n"
    csv_str += "rsi1_length," + str.tostring(rsi1_length) + "\n"
    csv_str += "rsi1_overbought," + str.tostring(rsi1_overbought) + "\n"
    csv_str += "rsi1_oversold," + str.tostring(rsi1_oversold) + "\n"
    csv_str += "useMA," + str.tostring(useMA ? 1 : 0) + "\n"
    csv_str += "ma_fast_length," + str.tostring(ma_fast_length) + "\n"
    csv_str += "ma_slow_length," + str.tostring(ma_slow_length) + "\n"
    csv_str += "ma_fast_type," + ma_fast_type + "\n"
    csv_str += "ma_slow_type," + ma_slow_type + "\n"
    csv_str += "useChannels," + str.tostring(useChannels ? 1 : 0) + "\n"
    csv_str += "channel_type," + channel_type + "\n"
    csv_str += "channel_length," + str.tostring(channel_length) + "\n"
    csv_str += "channel_multiplier," + str.tostring(channel_multiplier) + "\n"
    csv_str += "useSupertrend," + str.tostring(useSupertrend ? 1 : 0) + "\n"
    csv_str += "supertrend_period," + str.tostring(supertrend_period) + "\n"
    csv_str += "supertrend_factor," + str.tostring(supertrend_factor) + "\n"
    csv_str += "useMACD," + str.tostring(useMACD ? 1 : 0) + "\n"
    csv_str += "macd_fast_length," + str.tostring(macd_fast_length) + "\n"
    csv_str += "macd_slow_length," + str.tostring(macd_slow_length) + "\n"
    csv_str += "macd_signal_length," + str.tostring(macd_signal_length) + "\n"
    
    // Display export CSV
    var table export_table = table.new(position.middle_center, 1, 2, bgcolor=color.new(color.black, 80))
    table.cell(export_table, 0, 0, "CSV Export (Copy this):", text_color=color.yellow, text_size=size.normal)
    table.cell(export_table, 0, 1, csv_str, text_color=color.white, text_size=size.small)

// Display export hint
if show_export and barstate.islast
    var table hint_table = table.new(position.middle_center, 1, 1, bgcolor=color.new(color.blue, 80))
    table.cell(hint_table, 0, 0, "Enable 'Generate Export String' to see CSV", text_color=color.white, text_size=size.normal)

// ================================
// END OF STRATEGY
// ================================